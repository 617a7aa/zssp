/* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this
* file, You can obtain one at https://mozilla.org/MPL/2.0/.
*
* (c) ZeroTier, Inc.
* https://www.zerotier.com/
*/
// ZSSP: ZeroTier Secure Session Protocol
// FIPS compliant Noise_XK with Jedi powers (Kyber1024) and built-in attack-resistant large payload (fragmentation) support.

use std::cmp::Reverse;
use std::collections::HashMap;
use std::hash::Hash;
use std::num::{NonZeroU32, NonZeroU64};
use std::ops::DerefMut;
use std::sync::atomic::{AtomicBool, AtomicI64, AtomicU64, Ordering};
use std::sync::{Arc, Mutex, MutexGuard, RwLock, Weak};

use crate::crypto::aes::{AesDec, AesEnc};
use crate::crypto::aes_gcm::{AesGcmDec, AesGcmEnc, AES_GCM_IV_SIZE, AES_GCM_KEY_SIZE, AES_GCM_TAG_SIZE};
use crate::crypto::p384::{P384KeyPair, P384PublicKey, P384_ECDH_SHARED_SECRET_SIZE, P384_PUBLIC_KEY_SIZE};
use crate::crypto::pqc_kyber::KYBER_SECRETKEYBYTES;
use crate::crypto::rand_core::RngCore;
use crate::crypto::secret::{secure_eq, Secret};
use crate::crypto::sha512::{HmacSha512, Sha512};

use crate::error::{FaultType, OpenError, ReceiveError, SendError};
use crate::frag_cache::UnassociatedFragCache;
use crate::fragged::{Assembled, Fragged};
use crate::handshake_cache::UnassociatedHandshakeCache;
use crate::indexed_heap::{BinaryHeapIndex, IndexedBinaryHeap};
use crate::log_event::LogEvent;
use crate::proto::*;
use crate::symmetric_state::SymmetricState;
use crate::{applicationlayer::*, RatchetState};

/// Session context for local application.
///
/// Each application using ZSSP must create an instance of this to own sessions and
/// defragment incoming packets that are not yet associated with a session.
///
/// Internally this is just a clonable Arc, so it can be safely shared with multiple threads.
pub struct Context<Application: ApplicationLayer>(pub Arc<ContextInner<Application>>);
impl<Application: ApplicationLayer> Clone for Context<Application> {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
pub struct ContextInner<Application: ApplicationLayer> {
    static_keypair: Application::KeyPair,
    unassociated_defrag_cache: Mutex<UnassociatedFragCache<Application::IncomingPacketBuffer>>,
    unassociated_handshake_states: UnassociatedHandshakeCache<Application>,
    /// `session_queue -> state_machine_lock -> state -> session_map`
    session_queue: Mutex<IndexedBinaryHeap<Weak<Session<Application>>, Reverse<i64>>>,
    session_map: RwLock<HashMap<NonZeroU32, (Weak<Session<Application>>, bool)>>,
    challenge_counter: AtomicU64,
    challenge_antireplay_window: [AtomicU64; CHALLENGE_COUNTER_WINDOW_MAX_OOO],
    challenge_salt: [u8; CHALLENGE_SALT_SIZE],
    rng: Mutex<Application::Rng>,
}

/// Result generated by the context packet receive function, with possible payloads.
pub enum ReceiveResult<'b, Application: ApplicationLayer> {
    /// Packet superficially appeared valid but is not associated with a session yet.
    /// This can occur because the packet was only a fragment of a larger packet,
    /// or if it was a control packet that does not go through full Noise authentication.
    Unassociated,
    /// Packet was authentic and belongs to this specific session.
    Session(Arc<Session<Application>>, SessionEvent<'b>),
    /// Packet was a part of a handshake, and while it superficially appeared valid the application
    /// explicitly rejected it.
    /// Relates to callbacks `check_allow_incoming_session`, `hello_requires_recognized_ratchet`
    /// and `check_accept_session`.
    Rejected,
}

#[derive(Debug, PartialEq, Eq)]
pub enum SessionEvent<'b> {
    /// The received packet was valid, and it contained the necessary keys to fully establish a new
    /// session with Alice, the handshake initiator.
    ///
    /// If the session Arc returned is dropped, the session with this peer will be immediately
    /// terminated. Save the session Arc to some long lived datastructure to keep it alive.
    NewSession,
    /// When Alice calls `Context::open`, a session will be created, but Bob will not yet have
    /// received this session. They will have to successfully complete a handshake first.
    ///
    /// Alice will receive this return value when the received packet confirms both parties
    /// have completed the initial handshake and now have a shared session with each other.
    /// If according to the upper protocol, Bob is the first party to send data, it is possible for
    /// Alice to start receiving data from Bob before this value is returned.
    ///
    /// This return value can only occur once per session, only for session objects that were
    /// created with `Context::open`.
    Established,
    /// Bob explicitly refused to establish a session with Alice, and sent us an error code.
    /// The application should immediately drop this session as Bob will not allow us to connect.
    ///
    /// This return value cannot occur after a session is fully established.
    Rejected,
    /// The received packet was valid and a data payload was decoded and authenticated.
    Data(&'b mut [u8]),
    /// The received packet was some authentic protocol control packet. No action needs to be taken.
    Control,
}

#[derive(Debug, PartialEq, Eq)]
pub enum IncomingSessionAction {
    Allow,
    Challenge,
    Drop,
}

/// ZeroTier Secure Session Protocol (ZSSP) Session
///
/// A FIPS/NIST compliant variant of Noise_XK with hybrid Kyber1024 PQ data forward secrecy.
pub struct Session<Application: ApplicationLayer> {
    /// An arbitrary application defined object associated with each session.
    pub application_data: Application::Data,
    /// The receive context associated with this session,
    /// only this context can receive messages from the remote peer.
    context: Weak<ContextInner<Application>>,
    /// Handle into the session queue for changing the update timer.
    queue_idx: BinaryHeapIndex,

    remote_static_key: Application::PublicKey,
    send_counter: AtomicU64,
    /// This bool signals to all threads to stop incrementing the counter and instead error out.
    session_has_expired: AtomicBool,
    /// The following is a ring buffer of previously seen counter values, where we use the counter's
    /// value as the index of the head of the ring buffer.
    counter_antireplay_window: [AtomicU64; COUNTER_WINDOW_MAX_OOO],
    /// Enforces atomicity of state machine transitions.
    /// There is a standard locking sequence,
    /// it goes `session_queue -> state_machine_lock -> state -> session_map`.
    /// Any lock can be skipped but they must be locked in that order.
    state_machine_lock: Mutex<()>,
    state: RwLock<SessionMutableState<Application>>,
    defrag: [Mutex<Fragged<Application::IncomingPacketBuffer, MAX_FRAGMENTS>>; SESSION_MAX_FRAGMENTS_OOO],
    header_send_cipher: Application::PrpEnc,
    header_receive_cipher: Application::PrpDec,
    kex_send_cipher: Mutex<Option<Application::AeadEnc>>,
    kex_receive_cipher: Mutex<Option<Application::AeadDec>>,
    /// Pre-computed rekeying values.
    noise_kk_ss: Secret<P384_ECDH_SHARED_SECRET_SIZE>,
    noise_kk_local_init_h: [u8; NOISE_HASHLEN],
    noise_kk_remote_init_h: [u8; NOISE_HASHLEN],
    was_bob: bool,
}
/// `AesGcm` is not threadsafe, but it is threadsafe when inside a `Mutex`.
unsafe impl<Application: ApplicationLayer> Send for Session<Application> {}
unsafe impl<Application: ApplicationLayer> Sync for Session<Application> {}

/// Session state may only be mutated during atomic transitions of the offer state machine.
struct SessionMutableState<Application: ApplicationLayer> {
    ratchet_states: [RatchetState; 2],
    /// For OOO rekeying reliability we allow our version of Noise CipherState to hold the last two
    /// session keys, instead of just the most recent one.
    cipher_states: [Option<SessionKey<Application>>; 2],
    /// This is the index of `noise_cipher_state` that contains the most recent key.
    /// It will be attached to fragment headers to help with OOO transport.
    current_key: usize,
    /// This defines the exact state of the offer state machine we are in.
    outgoing_offer: OfferStateMachine<Application>,
}

/// These offer enums form a state machine.
/// Documented below are the only legal transitions for this state machine.
/// A session is initialized with an `outgoing_offer` of either NoiseXKPattern1 or Normal.
enum OfferStateMachine<Application: ApplicationLayer> {
    Normal {
        timeout: i64,
    }, // -> NoiseKKPattern1, NoiseKKPattern2
    /// This state uses a lot of memory so we put it on the heap.
    NoiseXKPattern1or3(Box<NoiseXKAliceHandshake<Application>>), // -> Normal
    NoiseKKPattern1 {
        next_retry_time: AtomicI64,
        timeout: i64,
        new_key_id: NonZeroU32,
        noise_e_secret: Application::KeyPair,
        noise_message: [u8; NoiseKKPattern1or2::SIZE],
        noise_ck: SymmetricState,
        noise_h_pskep: [u8; NOISE_HASHLEN],
    }, // -> NoiseKKPattern2, KeyConfirm
    NoiseKKPattern2 {
        next_retry_time: AtomicI64,
        timeout: i64,
        noise_message: [u8; NoiseKKPattern1or2::SIZE],
        kex_send_key: Secret<AES_GCM_KEY_SIZE>,
    }, // -> Normal
    KeyConfirm {
        next_retry_time: AtomicI64,
        timeout: i64,
    }, // -> Normal
}

pub(crate) struct NoiseXKBobHandshakeState<Application: ApplicationLayer> {
    /// Can never be Null.
    ratchet_state: RatchetState,
    remote_key_id: NonZeroU32,
    local_key_id: NonZeroU32,
    header_receive_key: Secret<AES_GCM_KEY_SIZE>,
    header_send_key: Secret<AES_GCM_KEY_SIZE>,
    noise_h_ee1peekem1pskp: [u8; NOISE_HASHLEN],
    noise_e_secret: Application::KeyPair,
    noise_ck_eseeekem1psk: SymmetricState,
    noise_k_eseeekem1psk: Secret<AES_GCM_KEY_SIZE>,
    noise_pattern3_defrag: Mutex<Fragged<Application::IncomingPacketBuffer, MAX_FRAGMENTS>>,
}

struct NoiseXKAliceHandshake<Application: ApplicationLayer> {
    next_retry_time: AtomicI64,
    timeout: i64,
    /// A secure random number put in the header of Alice's fragments to identify them.
    /// If a DDOS attacker could guess this they could block Alice starting the handshake.
    local_key_id: NonZeroU32,
    alice_identity_blob: Application::LocalIdentityBlob,
    offer: NoiseXKAliceHandshakeState<Application>,
}

enum NoiseXKAliceHandshakeState<Application: ApplicationLayer> {
    NoiseXKPattern1 {
        noise_h_ee1p: [u8; NOISE_HASHLEN],
        noise_e_secret: Application::KeyPair,
        noise_e1_secret: Secret<KYBER_SECRETKEYBYTES>,
        noise_ck_es: SymmetricState,
        /// ZSSP assumes an unreliable, out-of-order physical transport environment, so for that
        /// reason we have to resend key offers.
        noise_message: [u8; NoiseXKPattern1::MAX_SIZE],
        noise_message_len: usize,
        message_id: u64,
    },
    NoiseXKPattern3 {
        noise_message: [u8; NoiseXKPattern3::MAX_SIZE],
        noise_message_len: usize,
    },
}

struct SessionKey<Application: ApplicationLayer> {
    remote_key_id: NonZeroU32,
    local_key_id: NonZeroU32,
    /// Pool of reusable sending ciphers.
    receive_cipher_pool: [Mutex<Application::AeadDec>; 8],
    /// Pool of reusable receiving ciphers.
    send_cipher_pool: [Mutex<Application::AeadEnc>; 8],
    /// Rekey at or after this counter.
    rekey_at_counter: u64,
    /// Hard error when this counter value is reached or exceeded.
    expire_at_counter: u64,
}

macro_rules! byzantine_fault {
    ($name:expr, $is_natural:ident) => {
        ReceiveError::ByzantineFault {
            file: file!(),
            line: line!(),
            error: $name,
            is_naturally_occurring: $is_natural,
        }
    };
}

impl<Application: ApplicationLayer> Context<Application> {
    /// Create a new session context.
    pub fn new(static_keypair: Application::KeyPair, mut rng: Application::Rng) -> Self {
        debug_assert!(Application::REKEY_AFTER_TIME_MAX_JITTER_MS > 0, "Invalid protocol constant");
        let mut challenge_salt = [0u8; CHALLENGE_SALT_SIZE];
        rng.fill_bytes(&mut challenge_salt);
        Self(Arc::new(ContextInner {
            static_keypair,
            unassociated_defrag_cache: Mutex::new(UnassociatedFragCache::new()),
            unassociated_handshake_states: UnassociatedHandshakeCache::new(),
            session_map: RwLock::new(HashMap::new()),
            session_queue: Mutex::new(IndexedBinaryHeap::new()),
            challenge_counter: AtomicU64::new(INIT_COUNTER),
            challenge_antireplay_window: std::array::from_fn(|_| AtomicU64::new(0)),
            challenge_salt,
            rng: Mutex::new(rng),
        }))
    }

    /// Perform periodic background service and cleanup tasks.
    ///
    /// This returns the number of milliseconds until it should be called again. The caller should
    /// try to satisfy this but small variations in timing of up to +/- a second or two are not
    /// a problem.
    ///
    /// * `send_to` - Function to get a sender and an MTU to send something over an active session
    /// * `current_time` - Current time in milliseconds. Does not have to be monotonic, nor synced
    ///   with remote peers (although both of these properties would help reliability slightly).
    ///   Used to determine if any current handshakes should be resent or timed-out, or if a session
    ///   should rekey.
    #[inline]
    pub fn service<SendFn: FnMut(&mut [u8]) -> bool>(
        &self,
        app: &Application,
        mut send_to: impl FnMut(&Arc<Session<Application>>) -> Option<(SendFn, usize)>,
        current_time: i64,
    ) -> i64 {
        let retry_next = current_time.saturating_add(Application::RETRY_INTERVAL_MS);
        let mut next_service_time = 2 * Application::RETRY_INTERVAL_MS;

        let mut session_queue = self.0.session_queue.lock().unwrap();
        // This update system takes heavy advantage of the fact that sessions only need to be updated
        // either roughly every second or roughly every hour. That big gap allows for minor optimizations.
        // If the gap changes (unlikely) this code may need to be rewritten.
        while let Some((session, timer, queue_idx)) = session_queue.peek() {
            if timer.0 >= current_time {
                next_service_time = next_service_time.min(timer.0 - current_time);
                break;
            }
            let session = match session.upgrade() {
                Some(s) => s,
                _ => {
                    session_queue.remove(queue_idx);
                    continue;
                }
            };
            let state = session.state.read().unwrap();
            use OfferStateMachine::*;
            let next_timer = match &state.outgoing_offer {
                Normal { timeout, .. } => {
                    if *timeout <= current_time {
                        drop(state);
                        if let Some((send, _)) = send_to(&session) {
                            let result = initiate_rekey(&self.0, &session, send, current_time);
                            if result.is_ok() {
                                app.event_log(LogEvent::ServiceKKStart(&session), current_time);
                            }
                            result.unwrap_or(retry_next)
                        } else {
                            retry_next
                        }
                    } else {
                        *timeout
                    }
                }
                // If there's an outstanding attempt to open a session, retransmit this
                // periodically in case the initial packet doesn't make it.
                NoiseXKPattern1or3(handshake_state) => {
                    if let Some(ts) = process_timer(&handshake_state.next_retry_time, Application::RETRY_INTERVAL_MS, current_time) {
                        ts
                    } else {
                        // We have to eventually time out NoiseXKPattern3 because of unreliable network conditions.
                        if handshake_state.timeout <= current_time {
                            drop(state);
                            let _kex_lock = session.state_machine_lock.lock().unwrap();
                            let mut state = session.state.write().unwrap();
                            let ratchet_state = state.ratchet_states.clone();
                            // Since we dropped the lock we must re-check if we are in the correct state.
                            if let NoiseXKPattern1or3(handshake_state) = &mut state.outgoing_offer {
                                if handshake_state.timeout <= current_time {
                                    app.event_log(LogEvent::ServiceXKTimeout(&session), current_time);
                                    if !handshake_state.reinitialize(
                                        &session,
                                        &ratchet_state,
                                        &mut self.0.session_map.write().unwrap(),
                                        &mut self.0.rng.lock().unwrap(),
                                        current_time,
                                    ) {
                                        session.expire_inner(&self.0, &mut session_queue);
                                    }
                                }
                            }
                        } else if let Some((mut send, mut mtu)) = send_to(&session) {
                            mtu = mtu.max(MIN_TRANSPORT_MTU);
                            match &handshake_state.offer {
                                NoiseXKAliceHandshakeState::NoiseXKPattern1 { noise_message, noise_message_len, message_id, .. } => {
                                    app.event_log(LogEvent::ServiceXK1Resend(&session), current_time);
                                    // We are in state NoiseXKPattern1 so resend noise_pattern1.
                                    send_with_fragmentation(
                                        &mut send,
                                        mtu,
                                        &mut noise_message.clone()[..*noise_message_len],
                                        PACKET_TYPE_NOISE_XK_PATTERN_1,
                                        None,
                                        *message_id,
                                        None::<&Application::PrpEnc>,
                                    );
                                }
                                NoiseXKAliceHandshakeState::NoiseXKPattern3 { noise_message, noise_message_len, .. } => {
                                    app.event_log(LogEvent::ServiceXK3Resend(&session), current_time);
                                    send_with_fragmentation(
                                        &mut send,
                                        mtu,
                                        &mut noise_message.clone()[..*noise_message_len],
                                        PACKET_TYPE_NOISE_XK_PATTERN_3,
                                        state.cipher_states[0].as_ref().map(|k| k.remote_key_id),
                                        0,
                                        Some(&session.header_send_cipher),
                                    );
                                }
                            }
                        }
                        retry_next
                    }
                }
                NoiseKKPattern1 { next_retry_time, timeout, noise_message, .. } | NoiseKKPattern2 { next_retry_time, timeout, noise_message, .. } => {
                    if let Some(ts) = process_timer(next_retry_time, Application::RETRY_INTERVAL_MS, current_time) {
                        ts
                    } else {
                        if *timeout <= current_time {
                            app.event_log(LogEvent::ServiceKKTimeout(&session), current_time);
                            next_retry_time.store(i64::MAX, Ordering::Relaxed);
                            session.expire_inner(&self.0, &mut session_queue);
                        } else {
                            let packet_type = if let NoiseKKPattern1 { .. } = &state.outgoing_offer {
                                app.event_log(LogEvent::ServiceKK1Resend(&session), current_time);
                                PACKET_TYPE_NOISE_KK_PATTERN_1
                            } else {
                                app.event_log(LogEvent::ServiceKK2Resend(&session), current_time);
                                PACKET_TYPE_NOISE_KK_PATTERN_2
                            };
                            if let Some((send, _)) = send_to(&session) {
                                let _ = session.send_control(&state, send, packet_type, noise_message);
                            }
                        }
                        retry_next
                    }
                }
                KeyConfirm { next_retry_time, timeout, .. } => {
                    if let Some(ts) = process_timer(next_retry_time, Application::RETRY_INTERVAL_MS, current_time) {
                        ts
                    } else {
                        if *timeout <= current_time {
                            app.event_log(LogEvent::ServiceKeyConfirmTimeout(&session), current_time);
                            next_retry_time.store(i64::MAX, Ordering::Relaxed);
                            session.expire_inner(&self.0, &mut session_queue);
                        } else {
                            app.event_log(LogEvent::ServiceKeyConfirmResend(&session), current_time);
                            if let Some((send, _)) = send_to(&session) {
                                let _ = session.send_control(&state, send, PACKET_TYPE_KEY_CONFIRM, &[]);
                            }
                        }
                        retry_next
                    }
                }
            };
            session_queue.change_priority(queue_idx, Reverse(next_timer));
        }
        drop(session_queue);

        self.0
            .unassociated_defrag_cache
            .lock()
            .unwrap()
            .check_for_expiry(Application::INITIAL_OFFER_TIMEOUT_MS, current_time);
        self.0.unassociated_handshake_states.service(current_time);

        next_service_time
    }

    /// Create a new session and send initial packet(s) to other side.
    ///
    /// This will return SendError::DataTooLarge if the combined size of the metadata and the local
    /// static public blob (as retrieved from the application layer) exceed MAX_INIT_PAYLOAD_SIZE.
    ///
    /// * `app` - Application layer instance
    /// * `send` - Function to be called to send one or more initial packets to the remote being
    ///   contacted
    /// * `mtu` - MTU for initial packets
    /// * `remote_static_key` - Remote side's static public NIST P-384 key
    /// * `application_data` - Arbitrary data meaningful to the application to include with session
    ///   object
    /// * `ratchet_state` - The last saved and confirmed ratchet state associated with this remote
    ///   peer, or None if we do not have one.
    /// * `local_identity_blob` - Payload to be sent to Bob that contains the information necessary
    ///   for the upper protocol to authenticate and approve of Alice's identity.
    /// * `current_time` - Current time in milliseconds. Does not have to be monotonic, nor synced
    /// with the remote peer. Used to determine when this offer should be resent.
    #[inline]
    pub fn open(
        &self,
        app: &Application,
        mut send: impl FnMut(&mut [u8]) -> bool,
        mut mtu: usize,
        remote_static_key: Application::PublicKey,
        application_data: Application::Data,
        local_identity_blob: Application::LocalIdentityBlob,
        current_time: i64,
    ) -> Result<Arc<Session<Application>>, OpenError<Application::IoError>> {
        mtu = mtu.max(MIN_TRANSPORT_MTU);
        if local_identity_blob.as_ref().len() > MAX_IDENTITY_BLOB_SIZE {
            return Err(OpenError::DataTooLarge);
        }
        let result = app.restore_by_identity(&remote_static_key, &application_data, current_time);
        match result {
            Ok(ratchet_states) => {
                let sha512 = &mut Application::Hash::new();

                let mut noise_kk_ss = Secret::new();
                if !self.0.static_keypair.agree(&remote_static_key, noise_kk_ss.as_mut()) {
                    return Err(OpenError::InvalidPublicKey);
                }
                let noise_kk_local_init_h = mix_hash(sha512, &INITIAL_H_REKEY, self.0.static_keypair.public_key_bytes());
                let noise_kk_local_init_h = mix_hash(sha512, &noise_kk_local_init_h, remote_static_key.as_bytes());
                let noise_kk_remote_init_h = mix_hash(sha512, &INITIAL_H_REKEY, remote_static_key.as_bytes());
                let noise_kk_remote_init_h = mix_hash(sha512, &noise_kk_remote_init_h, self.0.static_keypair.public_key_bytes());

                let mut session_queue = self.0.session_queue.lock().unwrap();
                let mut session_map = self.0.session_map.write().unwrap();
                let local_key_id = generate_key_id(&session_map, &mut self.0.rng.lock().unwrap());
                // Begin Noise XKhfs+psk2.
                let (offer, a2b_header_key, b2a_header_key) =
                    NoiseXKAliceHandshake::<Application>::initialize(local_key_id, &remote_static_key, &ratchet_states, &mut self.0.rng.lock().unwrap())?;
                let handshake_state = Box::new(NoiseXKAliceHandshake {
                    next_retry_time: AtomicI64::new(current_time.saturating_add(Application::RETRY_INTERVAL_MS)),
                    timeout: current_time.saturating_add(Application::INITIAL_OFFER_TIMEOUT_MS),
                    local_key_id,
                    alice_identity_blob: local_identity_blob,
                    offer,
                });
                if let NoiseXKAliceHandshakeState::NoiseXKPattern1 { noise_message, noise_message_len, message_id, .. } = &handshake_state.offer {
                    send_with_fragmentation(
                        &mut send,
                        mtu,
                        &mut noise_message.clone()[..*noise_message_len],
                        PACKET_TYPE_NOISE_XK_PATTERN_1,
                        None,
                        *message_id,
                        None::<&Application::PrpEnc>,
                    );
                }

                let queue_idx = session_queue.reserve_index();
                let session = Arc::new(Session {
                    context: Arc::downgrade(&self.0),
                    queue_idx,
                    application_data,
                    remote_static_key,
                    send_counter: AtomicU64::new(INIT_COUNTER),
                    session_has_expired: AtomicBool::new(false),
                    counter_antireplay_window: std::array::from_fn(|_| AtomicU64::new(0)),
                    state_machine_lock: Mutex::new(()),
                    state: RwLock::new(SessionMutableState {
                        ratchet_states: ratchet_states.clone(),
                        cipher_states: [None, None],
                        // Points at 1 until the first key is confirmed.
                        current_key: 1,
                        outgoing_offer: OfferStateMachine::NoiseXKPattern1or3(handshake_state),
                    }),
                    header_send_cipher: Application::PrpEnc::new(a2b_header_key.as_ref()),
                    header_receive_cipher: Application::PrpDec::new(b2a_header_key.as_ref()),
                    kex_receive_cipher: Mutex::new(None),
                    kex_send_cipher: Mutex::new(None),
                    noise_kk_ss: noise_kk_ss.clone(),
                    noise_kk_local_init_h,
                    noise_kk_remote_init_h,
                    defrag: std::array::from_fn(|_| Mutex::new(Fragged::new())),
                    was_bob: false,
                });
                session_map.insert(local_key_id, (Arc::downgrade(&session), false));
                session_queue.push_reserved(
                    queue_idx,
                    Arc::downgrade(&session),
                    Reverse(current_time.saturating_add(Application::RETRY_INTERVAL_MS)),
                );

                Ok(session)
            }
            Err(e) => {
                Err(OpenError::RatchetIoError(e))
            }
        }
    }

    /// Receive, authenticate, decrypt, and process a physical wire packet.
    ///
    /// The check_allow_incoming_session function is called when an initial Noise_XK init message is
    /// received. This is before anything is known about the caller. A return value of true proceeds
    /// with negotiation. False drops the packet and ignores the inbound attempt.
    ///
    /// The check_accept_session function is called at the end of negotiation for an incoming
    /// session with the caller's static public blob. It must return the P-384 static public key
    /// extracted from the supplied blob and application data. A return of Some() accepts the
    /// session and will always result in a new session ReceiveResult being returned.
    ///
    /// * `app` - Interface to application using ZSSP
    /// * `check_allow_incoming_session` - Function to call to check whether an unidentified new
    ///   session should be accepted
    /// * `check_accept_session` - Function to accept sessions after final negotiation.
    ///   The second argument is the identity blob that the remote peer sent us. The application
    ///   must verify this identity is associated with the remote peer's static key.
    ///   The third argument is the ratchet chain length, or ratchet count.
    ///   To prevent desync, if this function returns (Some(_), _), no other open session with the
    ///   same remote peer must exist.
    /// * `send_unassociated_reply` - Function to send reply packets directly when no session exists
    /// * `send_unassociated_mtu` - MTU for unassociated replies
    /// * `send_to` - Function to get senders for existing sessions, permitting MTU and path lookup
    /// * `remote_address` - Whatever the remote address is, as long as you can Hash it
    /// * `data_buf` - Buffer to receive decrypted and authenticated object data (an error is
    ///   returned if too small)
    /// * `incoming_physical_packet_buf` - Buffer containing incoming wire packet
    ///   (receive() takes ownership)
    /// * `current_time` - Current time in milliseconds. Does not have to be monotonic, nor synced
    ///   with the remote peer. Used to check the state of local offers we may currently have or want
    ///   to put in-flight.
    #[inline]
    pub fn receive<'a, SendFn: FnMut(&mut [u8]) -> bool>(
        &self,
        app: &Application,
        check_allow_incoming_session: impl FnOnce() -> IncomingSessionAction,
        check_accept_session: impl FnOnce(&Application::PublicKey, &[u8], u64) -> (Option<(bool, Application::Data)>, bool),
        mut send_unassociated_reply: impl FnMut(&mut [u8]) -> bool,
        mut send_unassociated_mtu: usize,
        mut send_to: impl FnMut(&Arc<Session<Application>>) -> Option<(SendFn, usize)>,
        remote_address: &impl Hash,
        data_buf: &'a mut [u8],
        mut incoming_physical_packet_buf: Application::IncomingPacketBuffer,
        current_time: i64,
    ) -> Result<ReceiveResult<'a, Application>, ReceiveError<Application::IoError>> {
        send_unassociated_mtu = send_unassociated_mtu.max(MIN_TRANSPORT_MTU);
        let incoming_physical_packet: &mut [u8] = incoming_physical_packet_buf.as_mut();
        let incoming_physical_packet_len = incoming_physical_packet.len();
        if incoming_physical_packet_len < MIN_PACKET_SIZE {
            return Err(byzantine_fault!(FaultType::InvalidPacket, false));
        }

        // The first section parses the header and looks up relevant state information. If it's a DATA
        // or NOP packet it gets handled right here, otherwise we pull out a set of variables and
        // continue to the logic that handles KEX and session control packets.

        let mut assembled_packet = Assembled::new(); // needs to outlive the block below
        let mut incoming = None;
        let (session, packet_type, fragments) = {
            let mut local_key_id = [0u8; SESSION_ID_SIZE];
            local_key_id.copy_from_slice(&incoming_physical_packet[0..SESSION_ID_SIZE]);
            // `from_ne_bytes` because this id was generated locally.
            if let Some(local_key_id) = NonZeroU32::new(u32::from_ne_bytes(local_key_id)) {
                let session_map = self.0.session_map.read().unwrap();
                if let Some((Some(session), key_index)) = session_map.get(&local_key_id).map(|r| (r.0.upgrade(), r.1 as usize)) {
                    drop(session_map);
                    session.header_receive_cipher.decrypt_in_place(
                        (&mut incoming_physical_packet[HEADER_PROTECT_ENC_START..HEADER_PROTECT_ENC_END])
                            .try_into()
                            .unwrap(),
                    );
                    let (fragment_count, fragment_no, packet_type, incoming_counter, header_nonce) = parse_packet_header(incoming_physical_packet);
                    // Handle replay protection.
                    if PACKET_TYPE_RANGE_TRANSPORT.contains(&packet_type) {
                        // For DOS resistant reply-protection we need to check that the given counter is
                        // in the window of valid counters immediately.
                        // But for packets larger than 1 fragment we can't actually record the
                        // counter as received until we've authenticated the packet.
                        // So we check the counter window twice, and only update it the second time
                        // after the packet has been authenticated.
                        if !session.check_receive_window(incoming_counter) {
                            // This can occur naturally if packets arrive way out of order, or
                            // if they are duplicates.
                            // This can also be naturally triggered if Bob has just successfully
                            // received the first session key and is reject all of Alice's resends.
                            // This can also occur if a session was manually expired, but not
                            // dropped, and the remote party is still sending us data.
                            return Err(byzantine_fault!(FaultType::ExpiredCounter, true));
                        }
                        if packet_type != PACKET_TYPE_DATA {
                            // This is a control packet.
                            if fragment_count != 1 || fragment_no > 0 {
                                return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                            }
                            return receive_control_fragment(
                                self,
                                session,
                                app,
                                send_to,
                                packet_type,
                                incoming_counter,
                                incoming_physical_packet_buf.as_mut(),
                                current_time,
                            );
                        }
                    } else if packet_type == PACKET_TYPE_NOISE_XK_PATTERN_2 {
                        // We need to reject fragments marked with this type if they are sent out
                        // of sequence, since an attacker is able to replay them.
                        match &session.state.read().unwrap().outgoing_offer {
                            OfferStateMachine::NoiseXKPattern1or3(handshake_state) => match &handshake_state.offer {
                                NoiseXKAliceHandshakeState::NoiseXKPattern1 { .. } => {
                                    if incoming_counter >= COUNTER_WINDOW_MAX_SKIP_AHEAD {
                                        return Err(byzantine_fault!(FaultType::FailedAuthentication, false));
                                    }
                                }
                                // This error can occur naturally if Bob's initial reply to Alice had a
                                // resend that was delayed massively and arrived out of order.
                                NoiseXKAliceHandshakeState::NoiseXKPattern3 { .. } => return Err(byzantine_fault!(FaultType::OutOfSequence, true)),
                            },
                            _ => return Err(byzantine_fault!(FaultType::OutOfSequence, false)),
                        };
                    } else if packet_type == PACKET_TYPE_NOISE_XK_PATTERN_3 {
                        // This can be triggered if Bob successfully received a session key and
                        // needs to reject all of Alice's resends of PACKET_TYPE_NOISE_XK_PATTERN_3.
                        return Err(byzantine_fault!(FaultType::OutOfSequence, true));
                    } else {
                        return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                    }
                    // Handle defragmentation.
                    let fragments = if fragment_count > 1 {
                        let idx = incoming_counter as usize % session.defrag.len();
                        session.defrag[idx].lock().unwrap().assemble(
                            header_nonce,
                            incoming_physical_packet_buf,
                            fragment_no,
                            fragment_count,
                            &mut assembled_packet,
                        );
                        if assembled_packet.is_empty() {
                            // We have not yet authenticated the sender so we do not report
                            // receiving a packet from them.
                            return Ok(ReceiveResult::Unassociated);
                        } else {
                            assembled_packet.as_ref()
                        }
                    } else {
                        std::array::from_ref(&incoming_physical_packet_buf)
                    };
                    // Handle DATA in the fastest path when we have a session.
                    if packet_type == PACKET_TYPE_DATA {
                        let state = session.state.read().unwrap();
                        // The error here can occur because the other party is using a brand new
                        // session key that we have not received yet.
                        let key = state.cipher_states[key_index]
                            .as_ref()
                            .ok_or(byzantine_fault!(FaultType::OutOfSequence, true))?;
                        let mut c = key.get_receive_cipher(incoming_counter);
                        c.set_iv(&create_message_nonce(packet_type, incoming_counter));

                        let mut data_len = 0;

                        // Decrypt fragments 0..N-1 where N is the number of fragments.
                        for f in fragments[..(fragments.len() - 1)].iter() {
                            let f: &[u8] = f.as_ref();
                            debug_assert!(f.len() >= HEADER_SIZE);
                            let current_frag_data_start = data_len;
                            data_len += f.len() - HEADER_SIZE;
                            if data_len > data_buf.len() {
                                return Err(ReceiveError::DataBufferTooSmall);
                            }
                            c.decrypt(&f[HEADER_SIZE..], &mut data_buf[current_frag_data_start..data_len]);
                        }

                        // Decrypt final fragment (or only fragment if not fragmented)
                        let current_frag_data_start = data_len;
                        let last_fragment = fragments.last().unwrap().as_ref();
                        if last_fragment.len() < (HEADER_SIZE + AES_GCM_TAG_SIZE) {
                            return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                        }
                        data_len += last_fragment.len() - (HEADER_SIZE + AES_GCM_TAG_SIZE);
                        if data_len > data_buf.len() {
                            return Err(ReceiveError::DataBufferTooSmall);
                        }
                        let payload_end = last_fragment.len() - AES_GCM_TAG_SIZE;
                        c.decrypt(&last_fragment[HEADER_SIZE..payload_end], &mut data_buf[current_frag_data_start..data_len]);

                        let aead_authentication_ok = c.finish_decrypt(&last_fragment[payload_end..].try_into().unwrap());
                        drop(c);
                        drop(state);

                        if !aead_authentication_ok {
                            return Err(byzantine_fault!(FaultType::FailedAuthentication, false));
                        }
                        if !session.update_receive_window(incoming_counter) {
                            // This can be naturally triggered because Bob has just
                            // successfully received a session key and needs to reject
                            // all of Alice's resends.
                            // This can also occur naturally if some part of the outer
                            // system is duplicating the packets being sent to us.
                            // We are safely deduplicating them here.
                            return Err(byzantine_fault!(FaultType::ExpiredCounter, true));
                        }
                        // Packet fully authenticated
                        return Ok(ReceiveResult::Session(session, SessionEvent::Data(&mut data_buf[..data_len])));
                    } else if packet_type == PACKET_TYPE_NOISE_XK_PATTERN_2 {
                        (Some(session), packet_type, fragments)
                    } else {
                        unreachable!()
                    }
                } else {
                    drop(session_map);
                    // Check for and handle PACKET_TYPE_ALICE_NOISE_XK_PATTERN_3
                    incoming = self.0.unassociated_handshake_states.get(local_key_id);
                    if let Some(incoming) = incoming.as_ref() {
                        Application::PrpDec::new(incoming.header_receive_key.as_ref()).decrypt_in_place(
                            (&mut incoming_physical_packet[HEADER_PROTECT_ENC_START..HEADER_PROTECT_ENC_END])
                                .try_into()
                                .unwrap(),
                        );
                        let (fragment_count, fragment_no, packet_type, _, header_nonce) = parse_packet_header(incoming_physical_packet);
                        app.event_log(
                            LogEvent::ReceiveUnassociatedFragment(fragment_count, fragment_no, packet_type),
                            current_time,
                        );
                        if packet_type != PACKET_TYPE_NOISE_XK_PATTERN_3 {
                            return Err(byzantine_fault!(FaultType::OutOfSequence, false));
                        }
                        let fragments = if fragment_count > 1 {
                            incoming.noise_pattern3_defrag.lock().unwrap().assemble(
                                header_nonce,
                                incoming_physical_packet_buf,
                                fragment_no,
                                fragment_count,
                                &mut assembled_packet,
                            );
                            if !assembled_packet.is_empty() {
                                assembled_packet.as_ref()
                            } else {
                                return Ok(ReceiveResult::Unassociated);
                            }
                        } else {
                            std::array::from_ref(&incoming_physical_packet_buf)
                        };
                        // We must guarantee that this incoming handshake is processed once and only
                        // once. This prevents catastrophic nonce reuse caused by multithreading.
                        if self.0.unassociated_handshake_states.remove(local_key_id) {
                            (None, PACKET_TYPE_NOISE_XK_PATTERN_3, fragments)
                        } else {
                            return Ok(ReceiveResult::Unassociated);
                        }
                    } else {
                        // This can occur naturally because either Bob's incoming_sessions cache got
                        // full so Alice's incoming session was dropped, or the session this packet
                        // was for was dropped by the application.
                        return Err(byzantine_fault!(FaultType::UnknownLocalKeyId, true));
                    }
                }
            } else {
                let (fragment_count, fragment_no, packet_type, _, header_nonce) = parse_packet_header(incoming_physical_packet);
                app.event_log(
                    LogEvent::ReceiveUnassociatedFragment(fragment_count, fragment_no, packet_type),
                    current_time,
                );
                if packet_type != PACKET_TYPE_NOISE_XK_PATTERN_1 && packet_type != PACKET_TYPE_BOB_DOS_CHALLENGE {
                    return Err(byzantine_fault!(FaultType::OutOfSequence, false));
                }
                let fragments = if fragment_count > 1 {
                    self.0.unassociated_defrag_cache.lock().unwrap().assemble(
                        header_nonce,
                        remote_address,
                        incoming_physical_packet_len - HEADER_SIZE,
                        incoming_physical_packet_buf,
                        fragment_no,
                        fragment_count,
                        Application::RETRY_INTERVAL_MS,
                        current_time,
                        &mut assembled_packet,
                    );
                    if !assembled_packet.is_empty() {
                        assembled_packet.as_ref()
                    } else {
                        return Ok(ReceiveResult::Unassociated);
                    }
                } else {
                    std::array::from_ref(&incoming_physical_packet_buf)
                };
                (None, packet_type, fragments)
            }
        };

        debug_assert!(!fragments.is_empty());
        debug_assert!(incoming.is_none() || session.is_none());

        let message = &mut [0u8; MAX_NOISE_HANDSHAKE_SIZE];
        let message_size = assemble_fragments_into::<Application>(fragments, message)?;
        if message_size < MIN_PACKET_SIZE {
            return Err(byzantine_fault!(FaultType::InvalidPacket, false));
        }

        use OfferStateMachine::*;
        match packet_type {
            PACKET_TYPE_NOISE_XK_PATTERN_1 => {
                // Alice (remote) --> Bob (local)
                // -> e, es, e1
                app.event_log(LogEvent::ReceiveUncheckedXK1, current_time);

                if session.is_some() || incoming.is_some() {
                    return Err(byzantine_fault!(FaultType::OutOfSequence, false));
                }
                if !(NoiseXKPattern1::MIN_SIZE..=NoiseXKPattern1::MAX_SIZE).contains(&message_size) {
                    return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                }
                // The message id must be the first 8 bytes of the gcm tag.
                // This forces the message id to be authenticated along with the entire message.
                let p_auth_end = message_size - ChallengeResponse::SIZE;
                if message[8..16] != message[p_auth_end - 8..p_auth_end] {
                    return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                }
                let p_size = p_auth_end - NoiseXKPattern1::P_ENC_START - AES_GCM_TAG_SIZE;
                let total_ratchet_fingerprints = p_size / RATCHET_SIZE;
                if p_size % RATCHET_SIZE != 0 || total_ratchet_fingerprints > 2 {
                    return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                }

                let noise_pattern1: &NoiseXKPattern1 = byte_array_as_proto_buffer(message);
                if let Some(remote_key_id) = NonZeroU32::new(u32::from_ne_bytes(noise_pattern1.alice_key_id)) {
                    let sha512 = &mut Application::Hash::new();
                    // Let application filter incoming connection attempts by whatever criteria it wants.
                    // This should ideally prevent ZSSP from wasting time on DDOS attacks.
                    match check_allow_incoming_session() {
                        IncomingSessionAction::Allow => {}
                        IncomingSessionAction::Challenge => {
                            let response: &ChallengeResponse = byte_array_as_proto_buffer(&message[p_auth_end..message_size]);
                            let mut counter = 0u64.to_ne_bytes();
                            counter.copy_from_slice(&response.challenge_counter);
                            let counter = u64::from_be_bytes(counter);

                            sha512.reset();
                            let mut hasher = ShaHasher(sha512);
                            let mut output = [0u8; NOISE_HASHLEN];
                            hasher.0.update(&response.challenge_counter);
                            remote_address.hash(&mut hasher);
                            hasher.0.update(&self.0.challenge_salt);
                            hasher.0.finish(&mut output);
                            let is_valid = self.check_challenge_window(counter)
                                && secure_eq(&output[..CHALLENGE_MAC_SIZE], &response.challenge_mac)
                                && verify_pow::<Application>(hasher.0, &message[p_auth_end..message_size])
                                && self.update_challenge_window(counter);
                            app.event_log(LogEvent::ReceiveCheckXK1Challenge(is_valid), current_time);
                            if !is_valid {
                                // Alice failed the challenge so issue them a new challenge.
                                let mut challenge_buffer = [0u8; BobDOSChallenge::SIZE];
                                let challenge: &mut BobDOSChallenge = byte_array_as_proto_buffer_mut(&mut challenge_buffer);
                                challenge.alice_key_id = remote_key_id.get().to_ne_bytes();
                                // We attach a monotonically increasing counter value to the challenge
                                // so it cannot be replayed.
                                let counter = self.0.challenge_counter.fetch_add(1, Ordering::Relaxed);
                                challenge.challenge_counter = counter.to_be_bytes();

                                hasher.0.reset();
                                hasher.0.update(&counter.to_be_bytes());
                                remote_address.hash(&mut hasher);
                                hasher.0.update(&self.0.challenge_salt);
                                hasher.0.finish(&mut output);
                                challenge.challenge_mac.copy_from_slice(&output[..CHALLENGE_MAC_SIZE]);
                                challenge.prior_challenge_pow = response.challenge_pow;
                                // We haven't decrypted any of Alice's packet so we don't know the
                                // header protection cipher.
                                // For DOS resistance Alice will not accept unencrypted headers directly
                                // into their session defrag buffer, so we have to send them this reply
                                // through their incoming sessions cache.
                                send_with_fragmentation(
                                    &mut send_unassociated_reply,
                                    send_unassociated_mtu,
                                    &mut challenge_buffer,
                                    PACKET_TYPE_BOB_DOS_CHALLENGE,
                                    None,
                                    self.0.rng.lock().unwrap().next_u64(),
                                    None::<&Application::PrpEnc>,
                                );
                                return Ok(ReceiveResult::Unassociated);
                            }
                            // Alice succeeded at the challenge so continue to decryption.
                        }
                        IncomingSessionAction::Drop => return Ok(ReceiveResult::Rejected),
                    }

                    // Noise process handshake prologue.
                    let noise_h = mix_hash(
                        sha512,
                        &INITIAL_H,
                        &message[NoiseXKPattern1::PROLOGUE_START..NoiseXKPattern1::PROLOGUE_END],
                    );
                    let noise_h = mix_hash(sha512, &noise_h, self.0.static_keypair.public_key_bytes());
                    // Noise process pattern1 e token.
                    let mut noise_ck = SymmetricState::new(INITIAL_H);
                    let hmac = &mut Application::HmacHash::new();
                    let mut noise_es = Secret::new();
                    let noise_e_pattern1 = from_bytes_agreement::<Application>(&noise_pattern1.noise_e, &self.0.static_keypair, noise_es.as_mut())
                        .ok_or(byzantine_fault!(FaultType::FailedAuthentication, false))?;
                    let noise_h_e = mix_hash(sha512, &noise_h, &noise_pattern1.noise_e);
                    noise_ck.mix_key(hmac, &noise_pattern1.noise_e);
                    // Noise process pattern1 es token.
                    let noise_k_es = noise_ck.mix_key_initialize_key(hmac, noise_es.as_ref());
                    drop(noise_es);
                    // Noise process pattern1 e1 token.
                    let (is_auth, noise_h_ee1) = decrypt_and_hash::<Application>(
                        sha512,
                        &noise_k_es,
                        &noise_h_e,
                        packet_type,
                        0,
                        &mut message[NoiseXKPattern1::E1_ENC_START..NoiseXKPattern1::P_ENC_START],
                    );
                    if !is_auth {
                        // This could occur naturally if Alice's ApplicationLayer is dynamically
                        // changing their mtu, which in bad network conditions could clobber their
                        // resent KEX packet.
                        // Or maybe Alice randomly generated the same temporary id twice in a row.
                        // Since these situations are super unlikely to occur we still mark this error
                        // as unnatural.
                        return Err(byzantine_fault!(FaultType::FailedAuthentication, false));
                    }
                    // Noise process pattern1 payload.
                    let (is_auth, noise_h_ee1p) = decrypt_and_hash::<Application>(
                        sha512,
                        &noise_k_es,
                        &noise_h_ee1,
                        packet_type,
                        1,
                        &mut message[NoiseXKPattern1::P_ENC_START..p_auth_end],
                    );
                    drop(noise_k_es);
                    if !is_auth {
                        return Err(byzantine_fault!(FaultType::FailedAuthentication, false));
                    }
                    let (header_b2a_key, header_a2b_key) = noise_ck.get_ask2(hmac, LABEL_HEADER_KEY, &noise_h_ee1p);
                    // Get ratchet key.
                    let noise_pattern1: &NoiseXKPattern1 = byte_array_as_proto_buffer(message);
                    let mut ratchet_state = RatchetState::Null;
                    for i in 0..total_ratchet_fingerprints {
                        match app.restore_by_fingerprint(
                            (&noise_pattern1.payload[i * RATCHET_SIZE..(i + 1) * RATCHET_SIZE]).try_into().unwrap(),
                            current_time,
                        ) {
                            Ok(RatchetState::Null) | Ok(RatchetState::Empty) => {}
                            Ok(rs) => {
                                ratchet_state = rs;
                                break;
                            }
                            Err(e) => return Err(ReceiveError::RatchetIoError(e)),
                        }
                    }
                    if ratchet_state.is_null() {
                        if app.hello_requires_recognized_ratchet(current_time) {
                            return Ok(ReceiveResult::Rejected);
                        }
                        ratchet_state = RatchetState::Empty;
                    }

                    // Start of Noise XKhfs+psk2 pattern2.
                    let mut message2 = [0u8; NoiseXKPattern2::SIZE];
                    let noise_pattern2: &mut NoiseXKPattern2 = byte_array_as_proto_buffer_mut(&mut message2);
                    // Noise process pattern2 e token.
                    let noise_e_pattern2_secret = Application::KeyPair::generate(&mut self.0.rng.lock().unwrap());
                    noise_pattern2.noise_e = *noise_e_pattern2_secret.public_key_bytes();
                    let noise_h_ee1pe = mix_hash(sha512, &noise_h_ee1p, &noise_pattern2.noise_e);
                    noise_ck.mix_key(hmac, &noise_pattern2.noise_e);
                    // Noise process pattern2 ee token.
                    let mut noise_ee = Secret::new();
                    if !noise_e_pattern2_secret.agree(&noise_e_pattern1, noise_ee.as_mut()) {
                        return Err(byzantine_fault!(FaultType::FailedAuthentication, false));
                    }
                    let noise_k_esee = noise_ck.mix_key_initialize_key(hmac, noise_ee.as_ref());
                    drop(noise_ee);
                    // Noise process pattern2 ekem1 token.
                    let (noise_ekem1, noise_ekem1_secret) = pqc_kyber::encapsulate(&noise_pattern1.noise_e1, self.0.rng.lock().unwrap().deref_mut())
                        .map_err(|_| byzantine_fault!(FaultType::FailedAuthentication, false))
                        .map(|(ct, ekem1)| (ct, Secret(ekem1)))?;
                    // Alice fully authenticated.
                    noise_pattern2.noise_ekem1 = noise_ekem1;
                    let noise_h_ee1peekem1 = encrypt_and_hash::<Application>(
                        sha512,
                        &noise_k_esee,
                        &noise_h_ee1pe,
                        PACKET_TYPE_NOISE_XK_PATTERN_2,
                        0,
                        &mut message2[NoiseXKPattern2::EKEM1_ENC_START..NoiseXKPattern2::P_ENC_START],
                    );
                    drop(noise_k_esee);
                    noise_ck.mix_key(hmac, noise_ekem1_secret.as_ref());
                    drop(noise_ekem1_secret);
                    // Noise process pattern2 psk token.
                    let ratchet_key = ratchet_state.key().unwrap();
                    let (temp_h, noise_k_eseeekem1psk) = noise_ck.mix_key_and_hash_initialize_key(hmac, ratchet_key);
                    let noise_h_ee1peekem1psk = mix_hash(sha512, &noise_h_ee1peekem1, &temp_h);
                    // Noise process pattern2 payload.
                    // We try to prevent the id we generate from colliding with another session but
                    // because we might have handshakes in flight it's impossible to 100% prevent.
                    // In those exceedingly rare cases we have to drop Alice's session and start over.
                    let local_key_id = generate_key_id(&self.0.session_map.read().unwrap(), &mut self.0.rng.lock().unwrap());
                    let noise_pattern2: &mut NoiseXKPattern2 = byte_array_as_proto_buffer_mut(&mut message2);
                    noise_pattern2.bob_key_id = local_key_id.get().to_ne_bytes();

                    let noise_h_ee1peekem1pskp = encrypt_and_hash::<Application>(
                        sha512,
                        &noise_k_eseeekem1psk,
                        &noise_h_ee1peekem1psk,
                        PACKET_TYPE_NOISE_XK_PATTERN_2,
                        0,
                        &mut message2[NoiseXKPattern2::P_ENC_START..NoiseXKPattern2::P_AUTH_END],
                    );

                    app.event_log(LogEvent::ReceiveValidXK1, current_time);
                    let handshake = Arc::new(NoiseXKBobHandshakeState {
                        local_key_id,
                        remote_key_id,
                        ratchet_state,
                        noise_h_ee1peekem1pskp,
                        noise_ck_eseeekem1psk: noise_ck.clone(),
                        noise_k_eseeekem1psk: noise_k_eseeekem1psk.clone(),
                        noise_e_secret: noise_e_pattern2_secret,
                        header_receive_key: header_a2b_key.clone(),
                        header_send_key: header_b2a_key.clone(),
                        noise_pattern3_defrag: Mutex::new(Fragged::new()),
                    });
                    self.0.unassociated_handshake_states.insert(local_key_id, handshake, current_time);

                    // We put a copy of the gcm tag in the header so Alice can tell this packet apart
                    // from any other pattern 1 packet we send, without having to make Bob maintain state.
                    let mut pattern2_id = 0u64.to_ne_bytes();
                    pattern2_id[5] = message2[NoiseXKPattern2::P_AUTH_END - 3];
                    pattern2_id[6] = message2[NoiseXKPattern2::P_AUTH_END - 2];
                    pattern2_id[7] = message2[NoiseXKPattern2::P_AUTH_END - 1];
                    send_with_fragmentation(
                        &mut send_unassociated_reply,
                        send_unassociated_mtu,
                        &mut message2,
                        PACKET_TYPE_NOISE_XK_PATTERN_2,
                        Some(remote_key_id),
                        u64::from_be_bytes(pattern2_id),
                        Some(&Application::PrpEnc::new(header_b2a_key.first_n::<AES_GCM_KEY_SIZE>())),
                    );

                    return Ok(ReceiveResult::Unassociated);
                } else {
                    return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                }
            }
            PACKET_TYPE_BOB_DOS_CHALLENGE => {
                let message = &mut message[..message_size];
                app.event_log(LogEvent::ReceiveUncheckedDOSChallenge, current_time);

                // We expect Bob to only send this to us through our unassociated defrag cache.
                if incoming.is_some() || session.is_some() {
                    return Err(byzantine_fault!(FaultType::OutOfSequence, false));
                }
                if message.len() != BobDOSChallenge::SIZE {
                    return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                }
                let challenge: &BobDOSChallenge = byte_array_as_proto_buffer(message);

                if let Some(local_key_id) = NonZeroU32::new(u32::from_ne_bytes(challenge.alice_key_id)) {
                    if let Some(session) = self.0.session_map.read().unwrap().get(&local_key_id).and_then(|s| s.0.upgrade()) {
                        // We don't need to hold the kex lock because we are not transitioning state.
                        let mut state = session.state.write().unwrap();
                        if let NoiseXKPattern1or3(handshake_state) = &mut state.outgoing_offer {
                            if let NoiseXKAliceHandshakeState::NoiseXKPattern1 { noise_message, noise_message_len, .. } = &mut handshake_state.offer {
                                let response_raw = &mut noise_message[*noise_message_len - ChallengeResponse::SIZE..];

                                let response: &mut ChallengeResponse = byte_array_as_proto_buffer_mut(response_raw);
                                // Only people who know what Alice's prior pow was can convince us to
                                // compute a new pow.
                                if challenge.prior_challenge_pow != response.challenge_pow {
                                    // This can occur if Bob sends us multiple challenges and they
                                    // arrive OOO.
                                    return Err(byzantine_fault!(FaultType::FailedAuthentication, true));
                                }
                                response.challenge_counter.copy_from_slice(&challenge.challenge_counter);
                                response.challenge_mac.copy_from_slice(&challenge.challenge_mac);
                                let mut pow = self.0.rng.lock().unwrap().next_u64();
                                let sha512 = &mut Application::Hash::new();
                                loop {
                                    let response: &mut ChallengeResponse = byte_array_as_proto_buffer_mut(response_raw);
                                    response.challenge_pow.copy_from_slice(&pow.to_be_bytes());
                                    if verify_pow::<Application>(sha512, response_raw) {
                                        break;
                                    }
                                    pow = pow.wrapping_add(1);
                                }

                                app.event_log(LogEvent::ReceiveValidDOSChallenge(&session), current_time);
                                return Ok(ReceiveResult::Unassociated);
                            } else {
                                // This could happen if Bob challenges Alice, but their challenge packet
                                // gets massively delayed.
                                return Err(byzantine_fault!(FaultType::OutOfSequence, true));
                            }
                        } else {
                            // This could happen if Bob challenges Alice, but their challenge packet
                            // gets massively delayed.
                            return Err(byzantine_fault!(FaultType::OutOfSequence, true));
                        }
                    } else {
                        // This can occur naturally if Alice's session was dropped.
                        return Err(byzantine_fault!(FaultType::UnknownLocalKeyId, true));
                    }
                } else {
                    return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                }
            }
            PACKET_TYPE_NOISE_XK_PATTERN_2 => {
                // Bob (remote) --> Alice (local)
                // <- e, ee, ekem1, psk
                let message = &mut message[..message_size];
                app.event_log(LogEvent::ReceiveUncheckedXK2, current_time);

                if incoming.is_some() {
                    return Err(byzantine_fault!(FaultType::OutOfSequence, false));
                }
                if message.len() != NoiseXKPattern2::SIZE {
                    return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                }

                let session = session.ok_or(byzantine_fault!(FaultType::UnknownLocalKeyId, false))?;
                let kex_lock = session.state_machine_lock.lock().unwrap();
                let state = session.state.read().unwrap();

                if let NoiseXKPattern1or3(handshake_state) = &state.outgoing_offer {
                    if let NoiseXKAliceHandshakeState::NoiseXKPattern1 {
                        noise_h_ee1p, noise_e_secret, noise_e1_secret, noise_ck_es, ..
                    } = &handshake_state.offer
                    {
                        let noise_pattern2: &NoiseXKPattern2 = byte_array_as_proto_buffer(message);
                        // Authenticate header counter.
                        if noise_pattern2.header[13..16] != noise_pattern2.p_gcm_tag[13..16] {
                            return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                        }

                        // Noise process pattern2 e token.
                        let mut noise_ee = Secret::new();
                        if let Some(noise_e_pattern2) =
                            from_bytes_agreement::<Application>(&noise_pattern2.noise_e, noise_e_secret, noise_ee.as_mut())
                        {
                            let sha512 = &mut Application::Hash::new();
                            let hmac = &mut Application::HmacHash::new();
                            let mut noise_ck = noise_ck_es.clone();
                            let noise_h_ee1pe = mix_hash(sha512, noise_h_ee1p, noise_e_pattern2.as_bytes());
                            noise_ck.mix_key(hmac, noise_e_pattern2.as_bytes());
                            // Noise process pattern2 ee token.
                            let noise_k_esee = noise_ck.mix_key_initialize_key(hmac, noise_ee.as_ref());
                            drop(noise_ee);
                            // Noise process pattern2 ekem1 token.
                            let (is_auth, noise_h_ee1peekem1) = decrypt_and_hash::<Application>(
                                sha512,
                                &noise_k_esee,
                                &noise_h_ee1pe,
                                packet_type,
                                0,
                                &mut message[NoiseXKPattern2::EKEM1_ENC_START..NoiseXKPattern2::P_ENC_START],
                            );
                            let noise_pattern2: &NoiseXKPattern2 = byte_array_as_proto_buffer(message);
                            let noise_ekem1_secret = pqc_kyber::decapsulate(&noise_pattern2.noise_ekem1, noise_e1_secret.as_ref()).map(Secret);
                            if let Some(Ok(noise_ekem1_secret)) = is_auth.then_some(noise_ekem1_secret) {
                                noise_ck.mix_key(hmac, noise_ekem1_secret.as_ref());
                                drop(noise_ekem1_secret);

                                // We attempt to decrypt the payload at most three times. First two times with
                                // the ratchet key Alice remembers, and final time with a ratchet
                                // key of zero if Alice allows ratchet downgrades.
                                // The following code is not constant time, meaning we leak to an
                                // attacker whether or not we downgraded.
                                // We don't currently consider this sensitive enough information to hide.
                                let mut test_ratchet_key = |ratchet_key| -> Option<(NonZeroU32, SymmetricState, Secret<AES_GCM_KEY_SIZE>, [u8; 64])> {
                                    // Check for which ratchet key Bob wants to use.
                                    let mut noise_ck = noise_ck.clone();
                                    let mut payload = [0u8; NoiseXKPattern2::P_AUTH_END - NoiseXKPattern2::P_ENC_START];
                                    payload.copy_from_slice(&message[NoiseXKPattern2::P_ENC_START..NoiseXKPattern2::P_AUTH_END]);
                                    // Noise process pattern2 psk token.
                                    let (temp_h, noise_k_eseeekem1psk) = noise_ck.mix_key_and_hash_initialize_key(hmac, ratchet_key);
                                    let noise_h_ee1peekem1psk = mix_hash(sha512, &noise_h_ee1peekem1, &temp_h);
                                    // Noise process pattern2 payload.
                                    let (is_auth, noise_h_ee1peekem1pskp) = decrypt_and_hash::<Application>(
                                        sha512,
                                        &noise_k_eseeekem1psk,
                                        &noise_h_ee1peekem1psk,
                                        packet_type,
                                        0,
                                        &mut payload,
                                    );
                                    if is_auth {
                                        let key_id = NonZeroU32::new(u32::from_ne_bytes(
                                            (&payload[..NoiseXKPattern2::P_AUTH_START - NoiseXKPattern2::P_ENC_START])
                                                .try_into()
                                                .unwrap(),
                                        ));
                                        key_id.map(|kid| (kid, noise_ck, noise_k_eseeekem1psk, noise_h_ee1peekem1pskp))
                                    } else {
                                        None
                                    }
                                };
                                // Check first key.
                                let mut ratchet_i = 0;
                                let mut result = None;
                                let mut chain_len = 0;
                                if let Some(key) = state.ratchet_states[0].key() {
                                    chain_len = state.ratchet_states[0].chain_len();
                                    result = test_ratchet_key(key);
                                }
                                // Check second key.
                                if result.is_none() {
                                    ratchet_i = 1;
                                    if let Some(key) = state.ratchet_states[1].key() {
                                        chain_len = state.ratchet_states[1].chain_len();
                                        result = test_ratchet_key(key);
                                    }
                                }
                                // Check zero key.
                                if result.is_none() && !app.initiator_disallows_downgrade(&session, current_time) {
                                    chain_len = 0;
                                    result = test_ratchet_key(&[0u8; RATCHET_SIZE]);
                                    if result.is_some() {
                                        // TODO: add some kind of warning callback or signal.
                                    }
                                }

                                if let Some((remote_key_id, mut noise_ck, noise_k_eseeekem1psk, noise_h_ee1peekem1pskp)) = result {
                                    // Start of Noise XKhfs+psk2 pattern3.
                                    let mut message3 = [0u8; NoiseXKPattern3::MAX_SIZE];
                                    // Noise process pattern3 s token.
                                    let mut noise_se = Secret::new();
                                    if self.0.static_keypair.agree(&noise_e_pattern2, noise_se.as_mut()) {
                                        let payload = handshake_state.alice_identity_blob.as_ref();
                                        // Packet fully authenticated.
                                        let s_enc_start = HEADER_SIZE;
                                        let s_auth_start = s_enc_start + P384_PUBLIC_KEY_SIZE;
                                        let p_enc_start = s_auth_start + AES_GCM_TAG_SIZE;
                                        let p_auth_start = p_enc_start + payload.len();
                                        let p_auth_end = p_auth_start + AES_GCM_TAG_SIZE;
                                        let message3_len = p_auth_end;

                                        message3[s_enc_start..s_auth_start].copy_from_slice(self.0.static_keypair.public_key_bytes());
                                        let noise_h_ee1peekem1pskps = encrypt_and_hash::<Application>(
                                            sha512,
                                            &noise_k_eseeekem1psk,
                                            &noise_h_ee1peekem1pskp,
                                            PACKET_TYPE_NOISE_XK_PATTERN_3,
                                            1,
                                            &mut message3[s_enc_start..p_enc_start],
                                        );
                                        drop(noise_k_eseeekem1psk);
                                        // Noise process pattern3 se token.
                                        let noise_k_eseeekem1pskse = noise_ck.mix_key_initialize_key(hmac, noise_se.as_ref());
                                        drop(noise_se);
                                        // Noise process pattern3 payload token.
                                        message3[p_enc_start..p_auth_start].copy_from_slice(payload);
                                        let noise_h_ee1peekem1pskpsp = encrypt_and_hash::<Application>(
                                            sha512,
                                            &noise_k_eseeekem1pskse,
                                            &noise_h_ee1peekem1pskps,
                                            PACKET_TYPE_NOISE_XK_PATTERN_3,
                                            0,
                                            &mut message3[p_enc_start..p_auth_end],
                                        );
                                        drop(noise_k_eseeekem1pskse);
                                        // Alice finished Noise XKhfs+psk2 handshake.
                                        // Transition offer state machine to the NoiseXKPattern3 state.
                                        let (rk, rf) = noise_ck.get_ask2(hmac, LABEL_RATCHET_STATE, &noise_h_ee1peekem1pskpsp);
                                        let new_ratchet_state = RatchetState::new_nonempty(rk, rf, NonZeroU64::new(chain_len + 1).unwrap());

                                        let ratchet_to_preserve = &state.ratchet_states[ratchet_i];
                                        let result = app.save_ratchet_state(
                                            &session.remote_static_key,
                                            &session.application_data,
                                            [&state.ratchet_states[0], &state.ratchet_states[1]],
                                            [&new_ratchet_state, ratchet_to_preserve],
                                            current_time,
                                        );
                                        if let Err(e) = result {
                                            return Err(ReceiveError::RatchetIoError(e));
                                        }

                                        let (kex_key_b2a, kex_key_a2b) = noise_ck.get_ask2(hmac, LABEL_KEX_KEY, &noise_h_ee1peekem1pskpsp);

                                        let local_key_id = handshake_state.local_key_id;
                                        drop(state);
                                        let mut state = session.state.write().unwrap();
                                        session
                                            .kex_send_cipher
                                            .lock()
                                            .unwrap()
                                            .replace(Application::AeadEnc::new(kex_key_a2b.as_ref()));
                                        session
                                            .kex_receive_cipher
                                            .lock()
                                            .unwrap()
                                            .replace(Application::AeadDec::new(kex_key_b2a.as_ref()));
                                        state.ratchet_states[1] = state.ratchet_states[ratchet_i].clone();
                                        state.ratchet_states[0] = new_ratchet_state;

                                        state.cipher_states[0].replace(SessionKey::new(
                                            hmac,
                                            noise_ck,
                                            local_key_id,
                                            remote_key_id,
                                            INIT_COUNTER,
                                            false,
                                        ));
                                        debug_assert!(state.cipher_states[1].is_none());
                                        if let NoiseXKPattern1or3(handshake_state) = &mut state.outgoing_offer {
                                            handshake_state.next_retry_time =
                                                AtomicI64::new(current_time.saturating_add(Application::RETRY_INTERVAL_MS));
                                            handshake_state.timeout = current_time.saturating_add(Application::INITIAL_OFFER_TIMEOUT_MS);
                                            handshake_state.offer = NoiseXKAliceHandshakeState::NoiseXKPattern3 {
                                                noise_message: message3,
                                                noise_message_len: p_auth_end,
                                            };
                                        }
                                        drop(state);
                                        drop(kex_lock);

                                        if let Some((mut send, mut mtu)) = send_to(&session) {
                                            mtu = mtu.max(MIN_TRANSPORT_MTU);
                                            send_with_fragmentation(
                                                &mut send,
                                                mtu,
                                                &mut message3[..message3_len],
                                                PACKET_TYPE_NOISE_XK_PATTERN_3,
                                                Some(remote_key_id),
                                                0,
                                                Some(&session.header_send_cipher),
                                            );
                                        }
                                        app.event_log(LogEvent::ReceiveValidXK2(&session), current_time);
                                        return Ok(ReceiveResult::Session(session, SessionEvent::Control));
                                    }
                                }
                            }
                        }
                        // Bob failed authentication so we must restart our offer according to Noise.
                        // We restart the offer instead of dropping the session to defend against DOS.
                        drop(state);
                        let mut state = session.state.write().unwrap();
                        let ratchet_state = state.ratchet_states.clone();
                        if let NoiseXKPattern1or3(handshake_state) = &mut state.outgoing_offer {
                            if !handshake_state.reinitialize(
                                &session,
                                &ratchet_state,
                                &mut self.0.session_map.write().unwrap(),
                                &mut self.0.rng.lock().unwrap(),
                                current_time,
                            ) {
                                session.expire()
                            }
                        }
                        drop(state);
                        return Err(byzantine_fault!(FaultType::FailedAuthentication, false));
                    } else {
                        return Err(byzantine_fault!(FaultType::OutOfSequence, false));
                    }
                } else {
                    return Err(byzantine_fault!(FaultType::OutOfSequence, false));
                }
            }
            PACKET_TYPE_NOISE_XK_PATTERN_3 => {
                // Alice (remote) --> Bob (local)
                // -> s, se
                let message = &mut message[..message_size];
                app.event_log(LogEvent::ReceiveUncheckedXK3, current_time);

                if session.is_some() {
                    return Err(byzantine_fault!(FaultType::OutOfSequence, false));
                }
                if message.len() < NoiseXKPattern3::MIN_SIZE || message.len() > NoiseXKPattern3::MAX_SIZE {
                    return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                }
                // The code above guarantees to us that each `incoming` handshake state that reaches
                // this point will be strictly unique, even for the same remote peer.
                // This property is strictly necessary to prevent catastrophic nonce reuse due to
                // two session being created with the same set of keys.
                let handshake_state = incoming.ok_or(byzantine_fault!(FaultType::UnknownLocalKeyId, false))?;
                let s_enc_start = HEADER_SIZE;

                let s_auth_start = s_enc_start + P384_PUBLIC_KEY_SIZE;
                let p_enc_start = s_auth_start + AES_GCM_TAG_SIZE;
                let p_auth_end = message.len();
                let p_auth_start = p_auth_end - AES_GCM_TAG_SIZE;

                if !(p_enc_start <= p_auth_start) {
                    return Err(byzantine_fault!(FaultType::InvalidPacket, false));
                }
                // Do not read from the message before this point, otherwise an array out of bounds
                // error is possible.
                // Noise process pattern3 s token.
                let sha512 = &mut Application::Hash::new();
                let hmac = &mut Application::HmacHash::new();
                let (is_auth, noise_h_ee1peekem1pskps) = decrypt_and_hash::<Application>(
                    sha512,
                    &handshake_state.noise_k_eseeekem1psk,
                    &handshake_state.noise_h_ee1peekem1pskp,
                    packet_type,
                    1,
                    &mut message[s_enc_start..p_enc_start],
                );
                if !is_auth {
                    return Err(byzantine_fault!(FaultType::FailedAuthentication, false));
                }
                // Noise process pattern3 se token.
                let mut noise_se = Secret::new();
                if let Some(remote_s_public_key) =
                    from_bytes_agreement::<Application>(&message[s_enc_start..s_auth_start], &handshake_state.noise_e_secret, noise_se.as_mut())
                {
                    let mut noise_ck = handshake_state.noise_ck_eseeekem1psk.clone();
                    let noise_k_eseeekem1pskse = noise_ck.mix_key_initialize_key(hmac, noise_se.as_ref());
                    drop(noise_se);
                    // Noise process pattern3 payload.
                    let (is_auth, noise_h_ee1peekem1pskpsp) = decrypt_and_hash::<Application>(
                        sha512,
                        &noise_k_eseeekem1pskse,
                        &noise_h_ee1peekem1pskps,
                        packet_type,
                        0,
                        &mut message[p_enc_start..p_auth_end],
                    );
                    drop(noise_k_eseeekem1pskse);
                    if !is_auth {
                        return Err(byzantine_fault!(FaultType::FailedAuthentication, false));
                    }
                    // Bob finished Noise XKhfs+psk2 handshake.
                    let header_send_cipher = Application::PrpEnc::new(handshake_state.header_send_key.as_ref());
                    let (kex_key_b2a, kex_key_a2b) = noise_ck.get_ask2(hmac, LABEL_KEX_KEY, &noise_h_ee1peekem1pskpsp);
                    let mut send_reject = || {
                        // We just used a counter with this key, but we are not storing
                        // the fact we used it in memory. This is currently ok because the
                        // handshake is being dropped, so nonce reuse can't happen.
                        let (mut fragment, len) = encrypt_control(
                            &mut Application::AeadEnc::new(kex_key_b2a.as_ref()),
                            &header_send_cipher,
                            PACKET_TYPE_SESSION_REJECTED,
                            INIT_COUNTER,
                            handshake_state.remote_key_id.get(),
                            &[],
                        );
                        send_unassociated_reply(&mut fragment[..len]);
                    };

                    let (responder_disallows_downgrade, responder_silently_rejects) = check_accept_session(
                        &remote_s_public_key,
                        &message[p_enc_start..p_auth_start],
                        handshake_state.ratchet_state.chain_len(),
                    );
                    if let Some((responder_disallows_downgrade, application_data)) = responder_disallows_downgrade {
                        let result = app.restore_by_identity(&remote_s_public_key, &application_data, current_time);
                        match result {
                            Ok(true_ratchet_states) => {
                            let mut has_match = false;
                            for rs in &true_ratchet_states {
                                if !rs.is_null() {
                                    has_match |= &handshake_state.ratchet_state == rs;
                                }
                            }
                            if !has_match {
                                if !responder_disallows_downgrade && handshake_state.ratchet_state.is_empty() {
                                    // TODO: add some kind of warning callback or signal.
                                } else {
                                    if !responder_silently_rejects {
                                        send_reject();
                                    }
                                    return Err(byzantine_fault!(FaultType::FailedAuthentication, false));
                                }
                            }

                            let mut noise_kk_ss = Secret::new();
                            if !self.0.static_keypair.agree(&remote_s_public_key, noise_kk_ss.as_mut()) {
                                return Err(byzantine_fault!(FaultType::FailedAuthentication, false));
                            }
                            let noise_kk_local_init_h = mix_hash(sha512, &INITIAL_H_REKEY, self.0.static_keypair.public_key_bytes());
                            let noise_kk_local_init_h = mix_hash(sha512, &noise_kk_local_init_h, remote_s_public_key.as_bytes());
                            let noise_kk_remote_init_h = mix_hash(sha512, &INITIAL_H_REKEY, remote_s_public_key.as_bytes());
                            let noise_kk_remote_init_h = mix_hash(sha512, &noise_kk_remote_init_h, self.0.static_keypair.public_key_bytes());

                            let (rk, rf) = noise_ck.get_ask2(hmac, LABEL_RATCHET_STATE, &noise_h_ee1peekem1pskpsp);
                            // We must make sure the ratchet key is saved before we transition.
                            let new_ratchet_state =
                                RatchetState::new_nonempty(rk, rf, NonZeroU64::new(handshake_state.ratchet_state.chain_len() + 1).unwrap());
                            let result = app.save_ratchet_state(
                                &remote_s_public_key,
                                &application_data,
                                [&true_ratchet_states[0], &true_ratchet_states[1]],
                                [&new_ratchet_state, &RatchetState::Null],
                                current_time,
                            );
                            if let Err(e) = result {
                                return Err(ReceiveError::RatchetIoError(e));
                            }


                            let mut session_queue = self.0.session_queue.lock().unwrap();
                            let queue_idx = session_queue.reserve_index();
                            let session = Arc::new(Session {
                                context: Arc::downgrade(&self.0),
                                queue_idx,
                                application_data,
                                remote_static_key: remote_s_public_key,
                                send_counter: AtomicU64::new(INIT_COUNTER),
                                session_has_expired: AtomicBool::new(false),
                                counter_antireplay_window: std::array::from_fn(|_| AtomicU64::new(0)),
                                state_machine_lock: Mutex::new(()),
                                state: RwLock::new(SessionMutableState {
                                    ratchet_states: [new_ratchet_state.clone(), RatchetState::Null],
                                    cipher_states: [
                                        Some(SessionKey::new(
                                            hmac,
                                            noise_ck,
                                            handshake_state.local_key_id,
                                            handshake_state.remote_key_id,
                                            INIT_COUNTER,
                                            true,
                                        )),
                                        None,
                                    ],
                                    current_key: 0,
                                    outgoing_offer: KeyConfirm {
                                        next_retry_time: AtomicI64::new(current_time.saturating_add(Application::RETRY_INTERVAL_MS)),
                                        timeout: current_time.saturating_add(Application::EXPIRATION_TIMEOUT_MS),
                                    },
                                }),
                                header_receive_cipher: Application::PrpDec::new(handshake_state.header_receive_key.as_ref()),
                                header_send_cipher,
                                kex_send_cipher: Mutex::new(Some(Application::AeadEnc::new(kex_key_b2a.as_ref()))),
                                kex_receive_cipher: Mutex::new(Some(Application::AeadDec::new(kex_key_a2b.as_ref()))),
                                noise_kk_ss,
                                noise_kk_local_init_h,
                                noise_kk_remote_init_h,
                                defrag: std::array::from_fn(|_| Mutex::new(Fragged::new())),
                                was_bob: true,
                            });
                            let timer = Reverse(current_time.saturating_add(Application::RETRY_INTERVAL_MS));
                            session_queue.push_reserved(queue_idx, Arc::downgrade(&session), timer);
                            drop(session_queue);
                            // There is the miniscule possibility this key id is already
                            // in use, in which case we have to drop this session like
                            // nothing ever happened.
                            let mut session_map = self.0.session_map.write().unwrap();
                            if let std::collections::hash_map::Entry::Vacant(e) = session_map.entry(handshake_state.local_key_id) {
                                e.insert((Arc::downgrade(&session), false));
                                drop(session_map);
                                let _ = session.send_control(&session.state.read().unwrap(), send_unassociated_reply, PACKET_TYPE_KEY_CONFIRM, &[]);

                                app.event_log(LogEvent::ReceiveValidXK3(&session.application_data), current_time);
                                return Ok(ReceiveResult::Session(session, SessionEvent::NewSession));
                            } else {
                                // This can occur if we accidentally generate a key id collision.
                                // There is an extremely short amount of time during which
                                // another session can steal this session's id, we'll have to
                                // restart the handshake in this case.
                                return Err(byzantine_fault!(FaultType::UnknownLocalKeyId, true));
                            }
                        }
                        Err(e) => {
                            return Err(ReceiveError::RatchetIoError(e));
                        }
                    }
                    } else {
                        if !responder_silently_rejects {
                            send_reject();
                        }
                        return Ok(ReceiveResult::Rejected);
                    }
                } else {
                    return Err(byzantine_fault!(FaultType::FailedAuthentication, false));
                }
            }
            _ => return Err(byzantine_fault!(FaultType::InvalidPacket, false)),
        }
    }
    /// Helper function for sending the empty string over the session. Useful for keep-alives.
    ///
    /// * `session` - The session to send to
    /// * `send` - Function to call to send physical packet(s); the buffer passed to `send` is a
    ///   slice of `data`
    /// * `current_time` - Current time in milliseconds
    #[inline]
    pub fn send_empty(&self, session: &Arc<Session<Application>>, send: impl FnMut(&mut [u8]) -> bool, current_time: i64) -> Result<(), SendError> {
        self.send(session, send, &mut [0u8; MIN_TRANSPORT_MTU], &[], current_time)
    }
    /// Send data over the session.
    ///
    /// * `session` - The session to send to
    /// * `send` - Function to call to send physical packet(s); the buffer passed to `send` is a
    ///   slice of `data`
    /// * `mtu_sized_buffer` - A writable work buffer whose size equals the MTU
    /// * `data` - Data to send
    /// * `current_time` - Current time in milliseconds
    #[inline]
    pub fn send(
        &self,
        session: &Arc<Session<Application>>,
        mut send: impl FnMut(&mut [u8]) -> bool,
        mtu_sized_buffer: &mut [u8],
        mut data: &[u8],
        current_time: i64,
    ) -> Result<(), SendError> {
        if mtu_sized_buffer.len() < MIN_TRANSPORT_MTU {
            return Err(SendError::InvalidParameter);
        }
        let state = session.state.read().unwrap();
        let key = state.cipher_states[state.current_key].as_ref().ok_or(SendError::SessionNotEstablished)?;
        let counter = session.get_next_outgoing_counter()?;

        let mut c = key.get_send_cipher(counter)?;
        c.set_iv(&create_message_nonce(PACKET_TYPE_DATA, counter));

        let fragment_max_chunk_size = mtu_sized_buffer.len() - HEADER_SIZE;
        let fragment_count = (data.len() + AES_GCM_TAG_SIZE + (fragment_max_chunk_size - 1)) / fragment_max_chunk_size;
        if fragment_count > MAX_FRAGMENTS {
            return Err(SendError::DataTooLarge);
        }
        let last_fragment_no = fragment_count - 1;

        for fragment_no in 0..fragment_count {
            let chunk_size = fragment_max_chunk_size.min(data.len());
            let mut fragment_size = chunk_size + HEADER_SIZE;

            set_packet_header(
                mtu_sized_buffer,
                fragment_count as u8,
                fragment_no as u8,
                PACKET_TYPE_DATA,
                key.remote_key_id.get(),
                counter,
            );

            c.encrypt(&data[..chunk_size], &mut mtu_sized_buffer[HEADER_SIZE..fragment_size]);
            data = &data[chunk_size..];

            if fragment_no == last_fragment_no {
                debug_assert!(data.is_empty());
                let tagged_fragment_size = fragment_size + AES_GCM_TAG_SIZE;
                c.finish_encrypt((&mut mtu_sized_buffer[fragment_size..tagged_fragment_size]).try_into().unwrap());
                fragment_size = tagged_fragment_size;
            }

            session.header_send_cipher.encrypt_in_place(
                (&mut mtu_sized_buffer[HEADER_PROTECT_ENC_START..HEADER_PROTECT_ENC_END])
                    .try_into()
                    .unwrap(),
            );
            if !send(&mut mtu_sized_buffer[..fragment_size]) {
                break;
            }
        }
        drop(c);
        if counter >= key.rekey_at_counter {
            if let OfferStateMachine::Normal { .. } = &state.outgoing_offer {
                drop(state);
                if let Ok(timer) = initiate_rekey(&self.0, session, send, current_time) {
                    self.0.session_queue.lock().unwrap().change_priority(session.queue_idx, Reverse(timer));
                }
            }
        }
        Ok(())
    }
    /// Update the challenge window, returning true if the challenge is still valid.
    #[inline(always)]
    fn check_challenge_window(&self, counter: u64) -> bool {
        let slot = &self.0.challenge_antireplay_window[(counter as usize) % self.0.challenge_antireplay_window.len()];
        let counter = counter.wrapping_add(1);
        let prev_counter = slot.load(Ordering::Relaxed);
        prev_counter < counter
    }
    /// Update the challenge window, returning true if the challenge is still valid.
    #[inline(always)]
    fn update_challenge_window(&self, counter: u64) -> bool {
        let slot = &self.0.challenge_antireplay_window[(counter as usize) % self.0.challenge_antireplay_window.len()];
        let counter = counter.wrapping_add(1);
        let prev_counter = slot.fetch_max(counter, Ordering::Relaxed);
        prev_counter < counter
    }
}
/// Initiate the rekeying protocol. This session will now begin attempting to rekey this session
/// with its peer, if it was not already.
fn initiate_rekey<Application: ApplicationLayer>(
    context: &Arc<ContextInner<Application>>,
    session: &Arc<Session<Application>>,
    send: impl FnOnce(&mut [u8]) -> bool,
    current_time: i64,
) -> Result<i64, ()> {
    let mut message = [0u8; NoiseKKPattern1or2::SIZE];

    let kex_lock = session.state_machine_lock.lock().unwrap();
    let state = session.state.read().unwrap();
    // We may only attempt to rekey if we are not already doing so.
    match &state.outgoing_offer {
        OfferStateMachine::Normal { .. } => (),
        _ => return Err(()),
    }
    let sha512 = &mut Application::Hash::new();
    let hmac = &mut Application::HmacHash::new();
    // Start of Noise KKpsk0 pattern1.
    // Noise process pattern1 psk0 token.
    let mut noise_ck = SymmetricState::new(INITIAL_H_REKEY);
    let noise_temp_h = noise_ck.mix_key_and_hash(hmac, state.ratchet_states[0].key().unwrap());
    let noise_h_psk = mix_hash(sha512, &session.noise_kk_local_init_h, &noise_temp_h);
    // Noise process pattern1 e token.
    let noise_e_secret = Application::KeyPair::generate(&mut context.rng.lock().unwrap());
    let noise_h_pske = mix_hash(sha512, &noise_h_psk, noise_e_secret.public_key_bytes());
    noise_ck.mix_key(hmac, noise_e_secret.public_key_bytes());

    let noise_pattern1: &mut NoiseKKPattern1or2 = byte_array_as_proto_buffer_mut(&mut message);
    noise_pattern1.noise_e = *noise_e_secret.public_key_bytes();
    // Noise process pattern1 es token.
    let mut noise_es = Secret::new();
    if !noise_e_secret.agree(&session.remote_static_key, noise_es.as_mut()) {
        return Err(());
    }
    noise_ck.mix_key(hmac, noise_es.as_ref());
    drop(noise_es);
    // Noise process pattern1 ss token.
    let noise_k_pskesss = noise_ck.mix_key_initialize_key(hmac, session.noise_kk_ss.as_ref());
    // Noise process pattern1 payload token.
    let mut session_map = context.session_map.write().unwrap();
    let new_key_id = generate_key_id(&session_map, &mut context.rng.lock().unwrap());
    let next_key_index = state.current_key ^ 1;
    session_map.insert(new_key_id, (Arc::downgrade(session), next_key_index > 0));
    drop(session_map);

    let noise_pattern1: &mut NoiseKKPattern1or2 = byte_array_as_proto_buffer_mut(&mut message);
    noise_pattern1.key_id = new_key_id.get().to_ne_bytes();
    let noise_h_pskep = encrypt_and_hash::<Application>(
        sha512,
        &noise_k_pskesss,
        &noise_h_pske,
        PACKET_TYPE_NOISE_KK_PATTERN_1,
        0,
        &mut message[NoiseKKPattern1or2::ENC_START..NoiseKKPattern1or2::AUTH_END],
    );
    drop(noise_k_pskesss);

    drop(state);
    let mut state = session.state.write().unwrap();
    state.outgoing_offer = OfferStateMachine::NoiseKKPattern1 {
        next_retry_time: AtomicI64::new(current_time.saturating_add(Application::RETRY_INTERVAL_MS)),
        timeout: current_time.saturating_add(Application::EXPIRATION_TIMEOUT_MS),
        new_key_id,
        noise_e_secret,
        noise_message: message.clone(),
        noise_h_pskep,
        noise_ck: noise_ck.clone(),
    };
    drop(state);
    drop(kex_lock);
    let _ = session.send_control(&session.state.read().unwrap(), send, PACKET_TYPE_NOISE_KK_PATTERN_1, &message);
    Ok(current_time.saturating_add(Application::RETRY_INTERVAL_MS))
}
fn receive_control_fragment<'a, Application: ApplicationLayer, SendFn: FnMut(&mut [u8]) -> bool>(
    context: &Context<Application>,
    session: Arc<Session<Application>>,
    app: &Application,
    mut send_to: impl FnMut(&Arc<Session<Application>>) -> Option<(SendFn, usize)>,
    packet_type: u8,
    counter: u64,
    fragment: &mut [u8],
    current_time: i64,
) -> Result<ReceiveResult<'a, Application>, ReceiveError<Application::IoError>> {
    let state = session.state.read().unwrap();
    let mut c = session.kex_receive_cipher.lock().unwrap();
    let message = decrypt_control(
        c.as_mut().ok_or(byzantine_fault!(FaultType::OutOfSequence, false))?,
        packet_type,
        counter,
        fragment,
    )?;
    drop(c);
    session.update_receive_window(counter);
    use OfferStateMachine::*;
    return match packet_type {
        PACKET_TYPE_SESSION_REJECTED => match &state.outgoing_offer {
            NoiseXKPattern1or3(_) => {
                drop(state);
                Ok(ReceiveResult::Session(session, SessionEvent::Rejected))
            }
            _ => Err(byzantine_fault!(FaultType::OutOfSequence, false)),
        },
        PACKET_TYPE_KEY_CONFIRM => {
            drop(state);
            app.event_log(LogEvent::ReceiveValidKeyConfirm(&session), current_time);
            let kex_lock = session.state_machine_lock.lock().unwrap();
            let mut state = session.state.write().unwrap();
            // We only want to stop sending NoiseKKPattern2 offers when the latest derived
            // key is confirmed. And we only want to do that once.
            let (used_latest_key, try_delete, ret) = match &state.outgoing_offer {
                NoiseKKPattern2 { .. } => (true, true, SessionEvent::Control),
                NoiseXKPattern1or3(handshake_state) => {
                    if let NoiseXKAliceHandshakeState::NoiseXKPattern3 { .. } = &handshake_state.offer {
                        (true, true, SessionEvent::Established)
                    } else {
                        (false, false, SessionEvent::Control)
                    }
                }
                _ => (true, false, SessionEvent::Control),
            };
            if try_delete {
                let result = if !state.ratchet_states[1].is_null() {
                    app.save_ratchet_state(
                        &session.remote_static_key,
                        &session.application_data,
                        [&state.ratchet_states[0], &state.ratchet_states[1]],
                        [&state.ratchet_states[0], &RatchetState::Null],
                        current_time,
                    )
                } else {
                    Ok(())
                };
                if let Err(e) = result {
                    return Err(ReceiveError::RatchetIoError(e));
                }
                if let NoiseKKPattern2 { kex_send_key, .. } = &state.outgoing_offer {
                    session
                        .kex_send_cipher
                        .lock()
                        .unwrap()
                        .replace(Application::AeadEnc::new(kex_send_key.as_ref()));
                }
                state.ratchet_states[1] = RatchetState::Null;
                state.current_key ^= 1;
                state.outgoing_offer = new_normal_state(context.0.rng.lock().unwrap().next_u64(), current_time);
            }
            drop(state);
            drop(kex_lock);
            if used_latest_key {
                if let Some((send, _)) = send_to(&session) {
                    let _ = session.send_control(&session.state.read().unwrap(), send, PACKET_TYPE_ACK, &[]);
                }
            }
            Ok(ReceiveResult::Session(session, ret))
        }
        PACKET_TYPE_ACK => {
            drop(state);
            app.event_log(LogEvent::ReceiveValidAck(&session), current_time);
            let kex_lock = session.state_machine_lock.lock().unwrap();
            let mut state = session.state.write().unwrap();
            // Check if we should end any current offers and transition back to Normal state
            if let KeyConfirm { .. } = &state.outgoing_offer {
                state.outgoing_offer = new_normal_state(context.0.rng.lock().unwrap().next_u64(), current_time);
            }
            drop(state);
            drop(kex_lock);
            Ok(ReceiveResult::Session(session, SessionEvent::Control))
        }
        PACKET_TYPE_NOISE_KK_PATTERN_1 => {
            app.event_log(LogEvent::ReceiveUncheckedKK1, current_time);
            let message = &mut message[..NoiseKKPattern1or2::SIZE];
            let noise_pattern1: &NoiseKKPattern1or2 = byte_array_as_proto_buffer(message);

            drop(state);
            let kex_lock = session.state_machine_lock.lock().unwrap();
            let state = session.state.read().unwrap();
            // We need the following operation to be atomic with the change of offer type
            let (should_rekey_as_bob, chosen_id) = match &state.outgoing_offer {
                // Check rekey rate limits.
                Normal { .. } => (true, None),
                // In the following situation, both parties are in state NoiseKKPattern1,
                // we need to deterministically allow only one of them to transition to
                // NoiseKKPattern2.
                NoiseKKPattern1 { new_key_id, .. } => (session.was_bob, Some(*new_key_id)),
                _ => (false, None),
            };
            if !should_rekey_as_bob {
                // This can be triggered if both parties attempt rekeying simultaneously, or if the
                // remote party sent us a duplicate rekey request.
                // The code above handles this case and only lets one party through to rekeying.
                drop(state);
                drop(kex_lock);
                return Ok(ReceiveResult::Session(session, SessionEvent::Control));
            }
            // Noise process pattern1 psk0 token.
            let sha512 = &mut Application::Hash::new();
            let hmac = &mut Application::HmacHash::new();
            let mut noise_ck = SymmetricState::new(INITIAL_H_REKEY);
            let noise_temp_h = noise_ck.mix_key_and_hash(hmac, state.ratchet_states[0].key().unwrap());
            let noise_h_psk = mix_hash(sha512, &session.noise_kk_remote_init_h, &noise_temp_h);
            // Noise process pattern1 e token.
            // Get public key validation out of the way early
            let mut noise_es = Secret::new();
            let mut noise_ee = Secret::new();
            let mut noise_se = Secret::new();
            if let Some(alice_e) = from_bytes_agreement::<Application>(&noise_pattern1.noise_e, &context.0.static_keypair, noise_es.as_mut()) {
                let bob_e_secret = Application::KeyPair::generate(&mut context.0.rng.lock().unwrap());
                if bob_e_secret.agree(&alice_e, noise_ee.as_mut()) && bob_e_secret.agree(&session.remote_static_key, noise_se.as_mut()) {
                    let noise_h_pske = mix_hash(sha512, &noise_h_psk, alice_e.as_bytes());
                    noise_ck.mix_key(hmac, alice_e.as_bytes());
                    // Noise process pattern1 es token.
                    noise_ck.mix_key(hmac, noise_es.as_ref());
                    drop(noise_es);
                    // Noise process pattern1 ss token.
                    let noise_k_pskesss = noise_ck.mix_key_initialize_key(hmac, session.noise_kk_ss.as_ref());

                    // Noise process pattern1 payload.
                    let (is_auth, noise_h_pskep) = decrypt_and_hash::<Application>(
                        sha512,
                        &noise_k_pskesss,
                        &noise_h_pske,
                        packet_type,
                        0,
                        &mut message[NoiseKKPattern1or2::ENC_START..NoiseKKPattern1or2::AUTH_END],
                    );
                    let noise_pattern1: &NoiseKKPattern1or2 = byte_array_as_proto_buffer(message);
                    if let (true, Some(remote_key_id)) = (is_auth, NonZeroU32::new(u32::from_ne_bytes(noise_pattern1.key_id))) {
                        // Alice fully authenticated.
                        // Start of Noise KKpsk0 pattern2.
                        // Noise process pattern2 e token.
                        let noise_h_pskepe = mix_hash(sha512, &noise_h_pskep, bob_e_secret.public_key_bytes());
                        noise_ck.mix_key(hmac, bob_e_secret.public_key_bytes());
                        // Noise process pattern2 ee token.
                        noise_ck.mix_key(hmac, noise_ee.as_ref());
                        drop(noise_ee);
                        // Noise process pattern2 se token.
                        let noise_k_pskessseese = noise_ck.mix_key_initialize_key(hmac, noise_se.as_ref());
                        drop(noise_se);
                        // Noise process pattern2 payload.
                        let mut message2 = [0u8; NoiseKKPattern1or2::SIZE];
                        let noise_pattern2: &mut NoiseKKPattern1or2 = byte_array_as_proto_buffer_mut(&mut message2);
                        noise_pattern2.noise_e = *bob_e_secret.public_key_bytes();
                        let mut session_map = context.0.session_map.write().unwrap();
                        // If we already generated a new key id mapping reuse it.
                        let new_key_id = chosen_id.unwrap_or_else(|| generate_key_id(&session_map, &mut context.0.rng.lock().unwrap()));
                        noise_pattern2.key_id = new_key_id.get().to_ne_bytes();

                        let noise_h_pskepep = encrypt_and_hash::<Application>(
                            sha512,
                            &noise_k_pskessseese,
                            &noise_h_pskepe,
                            PACKET_TYPE_NOISE_KK_PATTERN_2,
                            0,
                            &mut message2[NoiseKKPattern1or2::ENC_START..NoiseKKPattern1or2::AUTH_END],
                        );
                        drop(noise_k_pskessseese);
                        // Bob finished Noise KKpsk0 handshake.
                        let (rk, rf) = noise_ck.get_ask2(hmac, LABEL_RATCHET_STATE, &noise_h_pskepep);
                        let new_ratchet_state = RatchetState::new_nonempty(rk, rf, NonZeroU64::new(state.ratchet_states[0].chain_len() + 1).unwrap());
                        let result = app.save_ratchet_state(
                            &session.remote_static_key,
                            &session.application_data,
                            [&state.ratchet_states[0], &state.ratchet_states[1]],
                            [&new_ratchet_state, &state.ratchet_states[0]],
                            current_time,
                        );
                        if let Err(e) = result {
                            drop(state);
                            drop(kex_lock);
                            return Err(ReceiveError::RatchetIoError(e));
                        }
                        let (kex_key_b2a, kex_key_a2b) = noise_ck.get_ask2(hmac, LABEL_KEX_KEY, &noise_h_pskepep);
                        // The new "Bob" doesn't know yet if Alice has received the new key, so the
                        // new key is recorded as the "alt" (key_index ^ 1) but the current key is
                        // not advanced yet.
                        let next_key_index = state.current_key ^ 1;
                        session_map.insert(new_key_id, (Arc::downgrade(&session), next_key_index > 0));
                        if let Some(pre_id) = state.cipher_states[next_key_index].as_ref().map(|k| k.local_key_id) {
                            session_map.remove(&pre_id);
                        }
                        drop(session_map);
                        drop(state);
                        let mut state = session.state.write().unwrap();
                        let current_counter = session.send_counter.load(Ordering::Relaxed);
                        session
                            .kex_receive_cipher
                            .lock()
                            .unwrap()
                            .replace(Application::AeadDec::new(kex_key_a2b.as_ref()));
                        state.ratchet_states[1] = state.ratchet_states[0].clone();
                        state.ratchet_states[0] = new_ratchet_state.clone();

                        state.cipher_states[next_key_index].replace(SessionKey::new(
                            hmac,
                            noise_ck,
                            new_key_id,
                            remote_key_id,
                            current_counter,
                            true,
                        ));
                        let timer = current_time.saturating_add(Application::RETRY_INTERVAL_MS);
                        state.outgoing_offer = NoiseKKPattern2 {
                            next_retry_time: AtomicI64::new(timer),
                            timeout: current_time.saturating_add(Application::EXPIRATION_TIMEOUT_MS),
                            noise_message: message2,
                            kex_send_key: kex_key_b2a.clone(),
                        };
                        drop(state);
                        drop(kex_lock);
                        context.0.session_queue.lock().unwrap().change_priority(session.queue_idx, Reverse(timer));

                        if let Some((send, _)) = send_to(&session) {
                            let _ = session.send_control(&session.state.read().unwrap(), send, PACKET_TYPE_NOISE_KK_PATTERN_2, &message2);
                        }
                        app.event_log(LogEvent::ReceiveValidKK1(&session), current_time);
                        return Ok(ReceiveResult::Session(session, SessionEvent::Control));
                    }
                }
            }
            Err(byzantine_fault!(FaultType::FailedAuthentication, false))
        }
        PACKET_TYPE_NOISE_KK_PATTERN_2 => {
            app.event_log(LogEvent::ReceiveUncheckedKK2, current_time);
            let message = &mut message[..NoiseKKPattern1or2::SIZE];
            let noise_pattern2: &NoiseKKPattern1or2 = byte_array_as_proto_buffer(message);

            drop(state);
            let kex_lock = session.state_machine_lock.lock().unwrap();
            let state = session.state.read().unwrap();
            if let NoiseKKPattern1 { new_key_id, noise_e_secret, noise_ck, noise_h_pskep, .. } = &state.outgoing_offer {
                // Noise process pattern2 e token.
                let mut noise_ee = Secret::new();
                let mut noise_se = Secret::new();
                if let Some(bob_e) = from_bytes_agreement::<Application>(&noise_pattern2.noise_e, noise_e_secret, noise_ee.as_mut()) {
                    if context.0.static_keypair.agree(&bob_e, noise_se.as_mut()) {
                        let sha512 = &mut Application::Hash::new();
                        let hmac = &mut Application::HmacHash::new();
                        let mut noise_ck = noise_ck.clone();
                        let noise_h_pskepe = mix_hash(sha512, noise_h_pskep, bob_e.as_bytes());
                        noise_ck.mix_key(hmac, bob_e.as_bytes());
                        // Noise process pattern2 ee token.
                        noise_ck.mix_key(hmac, noise_ee.as_ref());
                        drop(noise_ee);
                        // Noise process pattern2 se token.
                        let noise_k_pskessseese = noise_ck.mix_key_initialize_key(hmac, noise_se.as_ref());
                        drop(noise_se);
                        // Noise process pattern2 payload.
                        let (is_auth, noise_h_pskepep) = decrypt_and_hash::<Application>(
                            sha512,
                            &noise_k_pskessseese,
                            &noise_h_pskepe,
                            packet_type,
                            0,
                            &mut message[NoiseKKPattern1or2::ENC_START..NoiseKKPattern1or2::AUTH_END],
                        );
                        let noise_pattern2: &NoiseKKPattern1or2 = byte_array_as_proto_buffer(message);
                        if let (true, Some(remote_key_id)) = (is_auth, NonZeroU32::new(u32::from_ne_bytes(noise_pattern2.key_id))) {
                            // Bob fully authenticated.
                            // Alice finished Noise KKpsk0 handshake.
                            let (rk, rf) = noise_ck.get_ask2(hmac, LABEL_RATCHET_STATE, &noise_h_pskepep);
                            let new_ratchet_state =
                                RatchetState::new_nonempty(rk, rf, NonZeroU64::new(state.ratchet_states[0].chain_len() + 1).unwrap());
                            let result = app.save_ratchet_state(
                                &session.remote_static_key,
                                &session.application_data,
                                [&state.ratchet_states[0], &state.ratchet_states[1]],
                                [&new_ratchet_state, &RatchetState::Null],
                                current_time,
                            );
                            if let Err(e) = result {
                                drop(state);
                                drop(kex_lock);
                                return Err(ReceiveError::RatchetIoError(e));
                            }
                            let (kex_key_b2a, kex_key_a2b) = noise_ck.get_ask2(hmac, LABEL_KEX_KEY, &noise_h_pskepep);

                            let new_key_id = *new_key_id;
                            drop(state);
                            let mut state = session.state.write().unwrap();
                            let next_key_index = state.current_key ^ 1;
                            state.current_key = next_key_index;
                            if let Some(key) = state.cipher_states[next_key_index].as_ref() {
                                context.0.session_map.write().unwrap().remove(&key.local_key_id);
                            }
                            session
                                .kex_receive_cipher
                                .lock()
                                .unwrap()
                                .replace(Application::AeadDec::new(kex_key_b2a.as_ref()));
                            session
                                .kex_send_cipher
                                .lock()
                                .unwrap()
                                .replace(Application::AeadEnc::new(kex_key_a2b.as_ref()));
                            state.ratchet_states[1] = RatchetState::Null;
                            state.ratchet_states[0] = new_ratchet_state.clone();

                            state.cipher_states[next_key_index].replace(SessionKey::new(
                                hmac,
                                noise_ck,
                                new_key_id,
                                remote_key_id,
                                session.send_counter.load(Ordering::Relaxed),
                                false,
                            ));
                            state.outgoing_offer = KeyConfirm {
                                next_retry_time: AtomicI64::new(current_time.saturating_add(Application::RETRY_INTERVAL_MS)),
                                timeout: current_time.saturating_add(Application::EXPIRATION_TIMEOUT_MS),
                            };
                            drop(state);
                            drop(kex_lock);
                            // Let Bob know we got the key.
                            if let Some((send, _)) = send_to(&session) {
                                let _ = session.send_control(&session.state.read().unwrap(), send, PACKET_TYPE_KEY_CONFIRM, &[]);
                            }
                            app.event_log(LogEvent::ReceiveValidKK2(&session), current_time);
                            return Ok(ReceiveResult::Session(session, SessionEvent::Control));
                        }
                    }
                }
                // Bob failed authentication so according to Noise we must terminate this
                // handshake.
                // This should not happen in practice since this packet will have already passed
                // authentication under the current key.
                session.expire();
                Err(byzantine_fault!(FaultType::FailedAuthentication, false))
            } else {
                drop(state);
                drop(kex_lock);
                Ok(ReceiveResult::Session(session, SessionEvent::Control))
            }
        }
        _ => Err(byzantine_fault!(FaultType::InvalidPacket, false)),
    };
}

impl<Application: ApplicationLayer> Session<Application> {
    /// This can only fail with `MaxKeyLifetimeExceeded` or `SessionNotEstablished`.
    #[inline]
    fn send_control(
        &self,
        state: &SessionMutableState<Application>,
        send: impl FnOnce(&mut [u8]) -> bool,
        packet_type: u8,
        packet: &[u8],
    ) -> Result<(), SendError> {
        let key = state.cipher_states[state.current_key].as_ref().ok_or(SendError::SessionNotEstablished)?;
        let counter = self.get_next_outgoing_counter()?;
        let mut c = self.kex_send_cipher.lock().unwrap();
        let (mut fragment, len) = encrypt_control(
            c.as_mut().ok_or(SendError::SessionNotEstablished)?,
            &self.header_send_cipher,
            packet_type,
            counter,
            key.remote_key_id.get(),
            packet,
        );
        send(&mut fragment[..len]);
        Ok(())
    }
    /// Check whether this session is established.
    #[inline]
    pub fn established(&self) -> bool {
        let state = self.state.read().unwrap();
        !matches!(&state.outgoing_offer, OfferStateMachine::NoiseXKPattern1or3(_))
    }
    /// The static public key of the remote peer.
    #[inline]
    pub fn remote_s_public_key(&self) -> &Application::PublicKey {
        &self.remote_static_key
    }
    /// The current ratchet state of this session.
    /// The returned values are sensitive and should be securely erased before being dropped.
    #[inline]
    pub fn ratchet_states(&self) -> [RatchetState; 2] {
        let state = self.state.read().unwrap();
        state.ratchet_states.clone()
    }
    /// The current ratchet count of this session.
    #[inline]
    pub fn ratchet_count(&self) -> u64 {
        self.state.read().unwrap().ratchet_states[0].chain_len()
    }
    /// Mark a session as expired. This will make it impossible for this session to successfully
    /// receive or send data or control packets. It is recommended to simply `drop` the session
    /// instead, but this can provide some reassurance in complex shared ownership situations.
    pub fn expire(&self) {
        if let Some(context) = self.context.upgrade() {
            self.expire_inner(&context, &mut context.session_queue.lock().unwrap());
        }
    }
    fn expire_inner(
        &self,
        context: &Arc<ContextInner<Application>>,
        session_queue: &mut IndexedBinaryHeap<Weak<Session<Application>>, Reverse<i64>>,
    ) {
        // Prevent this session from being updated.
        session_queue.remove(self.queue_idx);
        self.session_has_expired.store(true, Ordering::Relaxed);
        let _kex_lock = self.state_machine_lock.lock().unwrap();
        let state = self.state.read().unwrap();
        let mut session_map = context.session_map.write().unwrap();
        for key in &state.cipher_states {
            if let Some(pre_id) = key.as_ref().map(|k| k.local_key_id) {
                session_map.remove(&pre_id);
            }
        }
        use OfferStateMachine::*;
        let id = match &state.outgoing_offer {
            NoiseXKPattern1or3(handshake_state) => handshake_state.local_key_id,
            NoiseKKPattern1 { new_key_id, .. } => *new_key_id,
            _ => return,
        };
        session_map.remove(&id);
    }

    /// Get the next outgoing counter value.
    #[inline(always)]
    fn get_next_outgoing_counter(&self) -> Result<u64, SendError> {
        if self.session_has_expired.load(Ordering::Relaxed) {
            Err(SendError::SessionExpired)
        } else {
            let counter = self.send_counter.fetch_add(1, Ordering::Relaxed);
            if counter > THREAD_SAFE_COUNTER_HARD_EXPIRE {
                // Because this thread sets the flag itself it will never be able to increment the
                // counter again.
                // For that reason the other atomic orderings can be `Relaxed`.
                self.session_has_expired.store(true, Ordering::SeqCst)
            }
            Ok(counter)
        }
    }
    /// Check the receive window without mutating state.
    #[inline(always)]
    fn check_receive_window(&self, counter: u64) -> bool {
        let slot = &self.counter_antireplay_window[(counter as usize) % self.counter_antireplay_window.len()];
        let counter = counter.wrapping_add(1);
        let prev_counter = slot.load(Ordering::Relaxed);
        prev_counter < counter && counter.wrapping_sub(prev_counter) <= COUNTER_WINDOW_MAX_SKIP_AHEAD
    }
    /// Update the receive window, returning true if the packet is still valid.
    /// This should only be called after the packet is authenticated.
    #[inline(always)]
    fn update_receive_window(&self, counter: u64) -> bool {
        let slot = &self.counter_antireplay_window[(counter as usize) % self.counter_antireplay_window.len()];
        let counter = counter.wrapping_add(1);
        let prev_counter = slot.fetch_max(counter, Ordering::Relaxed);
        prev_counter < counter && counter.wrapping_sub(prev_counter) <= COUNTER_WINDOW_MAX_SKIP_AHEAD
    }
}
impl<Application: ApplicationLayer> Drop for Session<Application> {
    fn drop(&mut self) {
        if let Some(context) = self.context.upgrade() {
            self.expire_inner(&context, &mut context.session_queue.lock().unwrap());
        }
    }
}

impl<Application: ApplicationLayer> NoiseXKAliceHandshake<Application> {
    /// Can only fail with `OpenError::InvalidPublicKey` because of remote_s_public_key.
    /// Corresponds to Noise `Initialize`.
    #[inline]
    fn initialize(
        local_key_id: NonZeroU32,
        remote_s_public_key: &Application::PublicKey,
        ratchet_state: &[RatchetState; 2],
        rng: &mut Application::Rng,
    ) -> Result<
        (
            NoiseXKAliceHandshakeState<Application>,
            Secret<AES_GCM_KEY_SIZE>,
            Secret<AES_GCM_KEY_SIZE>,
        ),
        OpenError<Application::IoError>,
    > {
        let mut message = [0u8; NoiseXKPattern1::MAX_SIZE];
        let sha512 = &mut Application::Hash::new();
        let hmac = &mut Application::HmacHash::new();
        // Start of Noise XKhfs+psk2 pattern1.
        let noise_pattern1: &mut NoiseXKPattern1 = byte_array_as_proto_buffer_mut(&mut message);
        let noise_e_secret = Application::KeyPair::generate(rng);
        let noise_e1_secret = pqc_kyber::keypair(rng);
        noise_pattern1.alice_key_id = local_key_id.get().to_ne_bytes();
        noise_pattern1.noise_e = *noise_e_secret.public_key_bytes();
        noise_pattern1.noise_e1 = noise_e1_secret.public;
        // Noise process prologue.
        let noise_h = mix_hash(
            sha512,
            &INITIAL_H,
            &message[NoiseXKPattern1::PROLOGUE_START..NoiseXKPattern1::PROLOGUE_END],
        );
        let noise_h = mix_hash(sha512, &noise_h, remote_s_public_key.as_bytes());
        // Noise process pattern1 e token.
        let mut noise_ck = SymmetricState::new(INITIAL_H);
        let noise_h_e = mix_hash(sha512, &noise_h, noise_e_secret.public_key_bytes());
        noise_ck.mix_key(hmac, noise_e_secret.public_key_bytes());
        // Noise process pattern1 es token.
        let mut noise_es = Secret::new();
        if !noise_e_secret.agree(remote_s_public_key, noise_es.as_mut()) {
            return Err(OpenError::InvalidPublicKey);
        }
        let noise_k_es = noise_ck.mix_key_initialize_key(hmac, noise_es.as_ref());
        drop(noise_es);
        // Noise process pattern1 e1 token.
        let noise_h_ee1 = encrypt_and_hash::<Application>(
            sha512,
            &noise_k_es,
            &noise_h_e,
            PACKET_TYPE_NOISE_XK_PATTERN_1,
            0,
            &mut message[NoiseXKPattern1::E1_ENC_START..NoiseXKPattern1::P_ENC_START],
        );
        // Noise process pattern1 payload.
        let noise_pattern1: &mut NoiseXKPattern1 = byte_array_as_proto_buffer_mut(&mut message);
        let mut idx = 0;
        for rs in ratchet_state {
            if let Some(rf) = rs.fingerprint() {
                let next_idx = idx + RATCHET_SIZE;
                noise_pattern1.payload[idx..next_idx].copy_from_slice(rf);
                idx = next_idx;
            }
        }
        let p_auth_end = NoiseXKPattern1::P_ENC_START + idx + AES_GCM_TAG_SIZE;
        let noise_message_len = p_auth_end + ChallengeResponse::SIZE;

        let noise_h_ee1p = encrypt_and_hash::<Application>(
            sha512,
            &noise_k_es,
            &noise_h_ee1,
            PACKET_TYPE_NOISE_XK_PATTERN_1,
            1,
            &mut message[NoiseXKPattern1::P_ENC_START..p_auth_end],
        );
        drop(noise_k_es);
        let (header_b2a_key, header_a2b_key) = noise_ck.get_ask2(hmac, LABEL_HEADER_KEY, &noise_h_ee1p);
        let message_id = u64::from_be_bytes(message[p_auth_end - 8..p_auth_end].try_into().unwrap());

        message[noise_message_len - CHALLENGE_POW_SIZE..noise_message_len].copy_from_slice(&rng.next_u64().to_ne_bytes());
        Ok((
            NoiseXKAliceHandshakeState::NoiseXKPattern1 {
                noise_h_ee1p,
                noise_e_secret,
                noise_e1_secret: Secret(noise_e1_secret.secret),
                noise_ck_es: noise_ck,
                noise_message_len,
                noise_message: message,
                message_id,
            },
            header_a2b_key,
            header_b2a_key,
        ))
    }
    /// Should not fail unless Bob's public key is adversarial.
    fn reinitialize(
        &mut self,
        session: &Arc<Session<Application>>,
        ratchet_state: &[RatchetState; 2],
        session_map: &mut HashMap<NonZeroU32, (Weak<Session<Application>>, bool)>,
        rng: &mut Application::Rng,
        current_time: i64,
    ) -> bool {
        let local_key_id = generate_key_id(session_map, rng);
        if let Ok((offer, a2b_header_key, b2a_header_key)) = Self::initialize(local_key_id, &session.remote_static_key, ratchet_state, rng) {
            self.timeout = current_time.saturating_add(Application::INITIAL_OFFER_TIMEOUT_MS);
            session_map.remove(&self.local_key_id);
            session_map.insert(local_key_id, (Arc::downgrade(session), false));
            self.local_key_id = local_key_id;
            self.offer = offer;
            session.header_send_cipher.reset(a2b_header_key.as_ref());
            session.header_receive_cipher.reset(b2a_header_key.as_ref());
            true
        } else {
            false
        }
    }
}

/// Create the normal state of the offer state machine, with the correct timestamps.
fn new_normal_state<Application: ApplicationLayer>(rand: u64, current_time: i64) -> OfferStateMachine<Application> {
    OfferStateMachine::Normal {
        timeout: current_time
            .saturating_add(Application::REKEY_AFTER_TIME_MS)
            .saturating_sub(rand as i64 % Application::REKEY_AFTER_TIME_MAX_JITTER_MS),
    }
}
/// Get a timestamp of when this timer should trigger next, or None if it should trigger now.
fn process_timer(timer: &AtomicI64, wait_time: i64, current_time: i64) -> Option<i64> {
    let ts = timer.load(Ordering::Relaxed);
    if ts <= current_time && timer.fetch_max(ts.saturating_add(wait_time), Ordering::Relaxed) == ts {
        None
    } else {
        Some(ts)
    }
}

/// Corresponds to Noise `EncryptAndHash`.
#[inline]
fn encrypt_and_hash<Application: ApplicationLayer>(
    sha512: &mut Application::Hash,
    noise_k: &Secret<AES_GCM_KEY_SIZE>,
    noise_h: &[u8; NOISE_HASHLEN],
    packet_type: u8,
    noise_k_uses: u64,
    message: &mut [u8],
) -> [u8; NOISE_HASHLEN] {
    let auth_start = message.len() - AES_GCM_TAG_SIZE;
    let mut gcm = Application::AeadEnc::new(noise_k.as_ref());
    // Encrypt and add authentication tag.
    gcm.set_iv(&create_message_nonce(packet_type, INIT_COUNTER + noise_k_uses));
    gcm.set_aad(noise_h);
    if auth_start > 0 {
        gcm.encrypt_in_place(&mut message[..auth_start]);
    }
    gcm.finish_encrypt((&mut message[auth_start..]).try_into().unwrap());
    mix_hash(sha512, noise_h, message)
}
/// Corresponds to Noise `DecryptAndHash`.
#[inline]
fn decrypt_and_hash<Application: ApplicationLayer>(
    sha512: &mut Application::Hash,
    noise_k: &Secret<AES_GCM_KEY_SIZE>,
    noise_h: &[u8; NOISE_HASHLEN],
    packet_type: u8,
    noise_k_uses: u64,
    message: &mut [u8],
) -> (bool, [u8; NOISE_HASHLEN]) {
    let auth_start = message.len() - AES_GCM_TAG_SIZE;
    let noise_h_c = mix_hash(sha512, noise_h, message);
    let mut gcm = Application::AeadDec::new(noise_k.as_ref());
    gcm.set_iv(&create_message_nonce(packet_type, INIT_COUNTER + noise_k_uses));
    gcm.set_aad(noise_h);
    if auth_start > 0 {
        gcm.decrypt_in_place(&mut message[..auth_start]);
    }
    (gcm.finish_decrypt((&message[auth_start..]).try_into().unwrap()), noise_h_c)
}
/// Encrypt a standardized control packet.
#[inline]
fn encrypt_control(
    c: &mut impl AesGcmEnc,
    header_cipher: &impl AesEnc,
    packet_type: u8,
    counter: u64,
    remote_key_id: u32,
    packet: &[u8],
) -> ([u8; CONTROL_PACKET_MAX_SIZE], usize) {
    let mut fragment = [0u8; CONTROL_PACKET_MAX_SIZE];
    let fragment_len = packet.len() + HEADER_SIZE + AES_GCM_TAG_SIZE;

    c.set_iv(&create_message_nonce(packet_type, counter));
    if !packet.is_empty(){
        fragment[HEADER_SIZE..fragment_len - AES_GCM_TAG_SIZE].copy_from_slice(packet);
        c.encrypt_in_place(&mut fragment[HEADER_SIZE..fragment_len - AES_GCM_TAG_SIZE]);
    }
    c.finish_encrypt((&mut fragment[fragment_len - AES_GCM_TAG_SIZE..fragment_len]).try_into().unwrap());
    set_packet_header(&mut fragment, 1, 0, packet_type, remote_key_id, counter);
    header_cipher.encrypt_in_place((&mut fragment[HEADER_PROTECT_ENC_START..HEADER_PROTECT_ENC_END]).try_into().unwrap());
    (fragment, fragment_len)
}
#[inline]
fn decrypt_control<'a, IoError>(c: &mut impl AesGcmDec, packet_type: u8, counter: u64, fragment: &'a mut [u8]) -> Result<&'a mut [u8], ReceiveError<IoError>> {
    let fragment_len = fragment.len();
    if !(CONTROL_PACKET_MIN_SIZE..=CONTROL_PACKET_MAX_SIZE).contains(&fragment_len) {
        return Err(byzantine_fault!(FaultType::InvalidPacket, false));
    }
    c.set_iv(&create_message_nonce(packet_type, counter));
    c.decrypt_in_place(&mut fragment[HEADER_SIZE..fragment_len - AES_GCM_TAG_SIZE]);
    if !c.finish_decrypt((&fragment[fragment_len - AES_GCM_TAG_SIZE..fragment_len]).try_into().unwrap()) {
        // This can occur naturally if one of the remote peers resent a
        // control packet that got delayed and arrived out of order.
        return Err(byzantine_fault!(FaultType::FailedAuthentication, true));
    }
    Ok(&mut fragment[HEADER_SIZE..fragment_len - AES_GCM_TAG_SIZE])
}

#[inline(always)]
fn set_packet_header(packet: &mut [u8], fragment_count: u8, fragment_no: u8, packet_type: u8, remote_key_id: u32, counter_or_id: u64) {
    debug_assert!(packet.len() >= MIN_PACKET_SIZE);
    debug_assert!(fragment_count > 0);
    debug_assert!(fragment_count <= MAX_FRAGMENTS as u8);
    debug_assert!(fragment_no < MAX_FRAGMENTS as u8);
    debug_assert_eq!((packet_type << 1) >> 1, packet_type);
    // [0..4]   recipient key id
    // -- start AES(ck_es * h_e_e1_p) encrypted block --
    // [4]      fragment count (1..255)
    // [5]      fragment number (0..254)
    // [6]      reserved zero
    // -- start of AES-GCM Nonce --
    // [7]      packet type
    // [8..16]  64-bit counter or packet id (big endian)
    packet[4..16].copy_from_slice(&create_message_nonce(packet_type, counter_or_id));
    packet[0..4].copy_from_slice(&remote_key_id.to_ne_bytes());
    packet[4] = fragment_count;
    packet[5] = fragment_no;
    packet[6] = 0;
}
/// Create a 96-bit AES-GCM nonce.
///
/// The primary information that we want to be contained here is the counter and the
/// packet type. The former makes this unique and the latter's inclusion authenticates
/// it as effectively AAD. Other elements of the header are either not authenticated,
/// like fragmentation info, or their authentication is implied via key exchange like
/// the key id.
#[inline(always)]
fn create_message_nonce(packet_type: u8, counter: u64) -> [u8; AES_GCM_IV_SIZE] {
    let mut ret = [0u8; AES_GCM_IV_SIZE];
    ret[3] = packet_type;
    // Noise requires a big endian counter at the end of the Nonce
    ret[4..].copy_from_slice(&counter.to_be_bytes());
    ret
}
/// returns `(fragment_count, fragment_no, packet_type, counter, header_nonce)`.
#[inline(always)]
fn parse_packet_header(packet: &[u8]) -> (u8, u8, u8, u64, [u8; 10]) {
    let mut header_nonce = [0; 10];
    let mut counter = 0u64.to_ne_bytes();
    header_nonce.copy_from_slice(&packet[6..16]);
    counter.copy_from_slice(&packet[8..16]);
    // We intentionally ignore the version number for future revisions.
    (packet[4], packet[5], packet[7], u64::from_be_bytes(counter), header_nonce)
}

/// Break a packet into fragments and send them all.
///
/// The contents of packet[] are mangled during this operation, so it should be discarded after.
/// This is only used for key exchange and control packets. For data packets this is done inline
/// for better performance with encryption and fragmentation happening at the same time.
fn send_with_fragmentation(
    send: &mut impl FnMut(&mut [u8]) -> bool,
    mtu: usize,
    packet: &mut [u8],
    packet_type: u8,
    remote_key_id: Option<NonZeroU32>,
    counter_or_id: u64,
    header_cipher: Option<&impl AesEnc>,
) -> bool {
    let packet_len = packet.len();
    let fragment_count = (packet_len.saturating_add(mtu - 1)) / mtu; // integer ceiling divide
    debug_assert!(fragment_count <= MAX_FRAGMENTS);
    let mut fragment_start = 0;
    let mut fragment_end = packet_len.min(mtu);
    let mut fragment_no = 0;
    loop {
        let fragment = &mut packet[fragment_start..fragment_end];
        set_packet_header(
            fragment,
            fragment_count as u8,
            fragment_no as u8,
            packet_type,
            remote_key_id.map_or(0, |n| n.get()),
            counter_or_id,
        );
        if let Some(hcc) = header_cipher {
            hcc.encrypt_in_place((&mut fragment[HEADER_PROTECT_ENC_START..HEADER_PROTECT_ENC_END]).try_into().unwrap());
        }
        if !send(fragment) {
            return false;
        }
        fragment_no += 1;
        if fragment_no < fragment_count {
            fragment_start = fragment_end - HEADER_SIZE;
            fragment_end = (fragment_start.saturating_add(mtu)).min(packet_len);
        } else {
            break;
        }
    }
    true
}

/// Assemble a series of fragments into a buffer and return the length of the assembled packet in
/// bytes.
///
/// This is also only used for key exchange and control packets. For data packets decryption and
/// assembly happen in one pass for better performance.
fn assemble_fragments_into<A: ApplicationLayer>(fragments: &[A::IncomingPacketBuffer], d: &mut [u8]) -> Result<usize, ReceiveError<A::IoError>> {
    let mut l = 0;
    for i in 0..fragments.len() {
        let mut ff = fragments[i].as_ref();
        if i > 0 {
            ff = &ff[HEADER_SIZE..];
        }
        let j = l + ff.len();
        if j > d.len() {
            return Err(byzantine_fault!(FaultType::InvalidPacket, false));
        }
        d[l..j].copy_from_slice(ff);
        l = j;
    }
    Ok(l)
}
/// Generate a random local key id that is currently unused.
fn generate_key_id<Application: ApplicationLayer>(
    session_map: &HashMap<NonZeroU32, (Weak<Session<Application>>, bool)>,
    rng: &mut Application::Rng,
) -> NonZeroU32 {
    loop {
        if let Some(local_key_id) = NonZeroU32::new(rng.next_u32()) {
            if !session_map.contains_key(&local_key_id) {
                return local_key_id;
            }
        }
    }
}

impl<Application: ApplicationLayer> SessionKey<Application> {
    #[inline(always)]
    fn new(
        hmac: &mut Application::HmacHash,
        ck: SymmetricState,
        local_key_id: NonZeroU32,
        remote_key_id: NonZeroU32,
        current_counter: u64,
        is_bob: bool,
    ) -> Self {
        let (b2a, a2b) = ck.split(hmac);
        let (receive_key, send_key) = if is_bob {
            (&a2b, &b2a)
        } else {
            (&b2a, &a2b)
        };
        let send_cipher_pool = std::array::from_fn(|_| Mutex::new(Application::AeadEnc::new(send_key.as_ref())));
        let receive_cipher_pool = std::array::from_fn(|_| Mutex::new(Application::AeadDec::new(receive_key.as_ref())));
        Self {
            local_key_id,
            remote_key_id,
            send_cipher_pool,
            receive_cipher_pool,
            rekey_at_counter: current_counter.saturating_add(Application::REKEY_AFTER_USES),
            expire_at_counter: current_counter.saturating_add(Application::EXPIRE_AFTER_USES),
        }
    }

    #[inline(always)]
    fn get_send_cipher(&self, counter: u64) -> Result<MutexGuard<Application::AeadEnc>, SendError> {
        if counter < self.expire_at_counter {
            Ok(self.send_cipher_pool[(counter as usize) % self.send_cipher_pool.len()].lock().unwrap())
        } else {
            Err(SendError::SessionExpired)
        }
    }

    #[inline(always)]
    fn get_receive_cipher(&self, counter: u64) -> MutexGuard<Application::AeadDec> {
        let idx = (counter as usize) % self.receive_cipher_pool.len();
        self.receive_cipher_pool[idx].lock().unwrap()
    }
}

/// MixHash to update 'h' during negotiation.
#[inline(always)]
fn mix_hash(hasher: &mut impl Sha512, h: &[u8; NOISE_HASHLEN], m: &[u8]) -> [u8; NOISE_HASHLEN] {
    let mut output = [0u8; NOISE_HASHLEN];
    hasher.reset();
    hasher.update(h);
    hasher.update(m);
    hasher.finish(&mut output);
    output
}
/// Check if the proof of work attached to the first message contains the correct number of leading
/// zeros.
#[inline(always)]
fn verify_pow<Application: ApplicationLayer>(hasher: &mut Application::Hash, response: &[u8]) -> bool {
    if Application::PROOF_OF_WORK_BIT_DIFFICULTY == 0 {
        return true;
    }
    hasher.reset();
    hasher.update(response);
    let mut output = [0u8; NOISE_HASHLEN];
    hasher.finish(&mut output);
    let n = u32::from_be_bytes(output[..4].try_into().unwrap());
    n.leading_zeros() >= Application::PROOF_OF_WORK_BIT_DIFFICULTY
}
#[inline(always)]
fn from_bytes_agreement<Application: ApplicationLayer>(
    public: &[u8],
    private: &Application::KeyPair,
    output: &mut [u8; P384_ECDH_SHARED_SECRET_SIZE],
) -> Option<Application::PublicKey> {
    Application::PublicKey::from_bytes(public.try_into().unwrap()).and_then(|e| private.agree(&e, output).then_some(e))
}
